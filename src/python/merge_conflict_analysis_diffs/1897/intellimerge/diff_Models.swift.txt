====1
1:14c
      case Error(Int, Data?, Error)
2:14,15c
3:14,15c
      case HttpError(statusCode: Int, data: Data?, error: Error)
      case DecodeError(response: Data?, decodeError: DecodeError)
====1
1:37a
2:39,60c
3:39,60c
  public enum Decoded<ValueType> {
      case success(ValueType)
      case failure(DecodeError)
  }
  
  public extension Decoded {
      var value: ValueType? {
          switch self {
          case let .success(value):
              return value
          case .failure:
              return nil
          }
      }
  }
  
  public enum DecodeError {
      case typeMismatch(expected: String, actual: String)
      case missingKey(key: String)
      case parseError(message: String)
  }
  
====1
1:42c
      static func addDecoder<T>(clazz: T.Type, decoder: @escaping ((AnyObject, AnyObject?) -> T)) {
2:65c
3:65c
      static func addDecoder<T>(clazz: T.Type, decoder: @escaping ((AnyObject, AnyObject?) -> Decoded<T>)) {
====1
1:47,50c
      static func decode<T>(clazz: T.Type, discriminator: String, source: AnyObject) -> T {
          let key = discriminator;
          if let decoder = decoders[key] {
              return decoder(source, nil) as! T
2:70,73c
3:70,73c
      static func decode<T>(clazz: T.Type, discriminator: String, source: AnyObject) -> Decoded<T> {
          let key = discriminator
          if let decoder = decoders[key], let value = decoder(source, nil) as? Decoded<T> {
              return value
====1
1:52c
              fatalError("Source \(source) is not convertible to type \(clazz): Maybe swagger file is insufficient")
2:75c
3:75c
              return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
====1
1:56,58c
      static func decode<T>(clazz: [T].Type, source: AnyObject) -> [T] {
          let array = source as! [AnyObject]
          return array.map { Decoders.decode(clazz: T.self, source: $0, instance: nil) }
2:79,93c
3:79,93c
      static func decode<T>(clazz: [T].Type, source: AnyObject) -> Decoded<[T]> {
          if let sourceArray = source as? [AnyObject] {
              var values = [T]()
              for sourceValue in sourceArray {
                  switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                  case let .success(value):
                      values.append(value)
                  case let .failure(error):
                      return .failure(error)
                  }
              }
              return .success(values)
          } else {
              return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
          }
====1
1:61,65c
      static func decode<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject) -> [Key:T] {
          let sourceDictionary = source as! [Key: AnyObject]
          var dictionary = [Key:T]()
          for (key, value) in sourceDictionary {
              dictionary[key] = Decoders.decode(clazz: T.self, source: value, instance: nil)
2:96,122c
3:96,122c
      static func decode<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject) -> Decoded<[Key:T]> {
          if let sourceDictionary = source as? [Key: AnyObject] {
              var dictionary = [Key:T]()
              for (key, value) in sourceDictionary {
                  switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                  case let .success(value):
                      dictionary[key] = value
                  case let .failure(error):
                      return .failure(error)
                  }
              }
              return .success(dictionary)
          } else {
              return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
          }
      }
  
      static func decodeOptional<T: RawRepresentable>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
          guard !(source is NSNull), source != nil else { return .success(nil) }
          if let value = source as? T.RawValue {
              if let enumValue = T.init(rawValue: value) {
                  return .success(enumValue)
              } else {
                  return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
              }
          } else {
              return .failure(.typeMismatch(expected: "\(T.RawValue.self) matching a case from the enumeration \(T.self)", actual: String(describing: type(of: source))))
====1
1:67c
          return dictionary
2:123a
3:123a
====1
1:70c
      static func decode<T>(clazz: T.Type, source: AnyObject, instance: AnyObject?) -> T {
2:126c
3:126c
      static func decode<T>(clazz: T.Type, source: AnyObject, instance: AnyObject?) -> Decoded<T> {
====1
1:72,73c
          if T.self is Int32.Type && source is NSNumber {
              return (source as! NSNumber).int32Value as! T;
2:128,129c
3:128,129c
          if let value = source.int32Value as? T, source is NSNumber, T.self is Int32.Type {
              return .success(value)
====1
1:75,76c
          if T.self is Int64.Type && source is NSNumber {
              return source.int64Value as! T;
2:131,132c
3:131,132c
          if let value = source.int32Value as? T, source is NSNumber, T.self is Int64.Type {
              return .success(value)
====1
1:78,79c
          if T.self is UUID.Type && source is String {
              return UUID(uuidString: source as! String) as! T
2:134,135c
3:134,135c
          if let intermediate = source as? String, let value = UUID(uuidString: intermediate) as? T, source is String, T.self is UUID.Type {
              return .success(value)
====1
1:81,82c
          if source is T {
              return source as! T
2:137,138c
3:137,138c
          if let value = source as? T {
              return .success(value)
====1
1:84,85c
          if T.self is Data.Type && source is String {
              return Data(base64Encoded: source as! String) as! T
2:140,141c
3:140,141c
          if let intermediate = source as? String, let value = Data(base64Encoded: intermediate) as? T {
              return .success(value)
====1
1:89,90c
          if let decoder = decoders[key] {
             return decoder(source, instance) as! T
2:145,146c
3:145,146c
          if let decoder = decoders[key], let value = decoder(source, instance) as? Decoded<T> {
             return value
====1
1:92c
              fatalError("Source \(source) is not convertible to type \(clazz): Maybe swagger file is insufficient")
2:148c
3:148c
              return .failure(.typeMismatch(expected: String(describing: clazz), actual: String(describing: source)))
====1
1:96,102c
      static func decodeOptional<T>(clazz: T.Type, source: AnyObject?) -> T? {
          if source is NSNull {
              return nil
          }
          return source.map { (source: AnyObject) -> T in
              Decoders.decode(clazz: clazz, source: source, instance: nil)
          }
2:152,154c
3:152,154c
      //Convert a Decoded so that its value is optional. DO WE STILL NEED THIS?
      static func toOptional<T>(decoded: Decoded<T>) -> Decoded<T?> {
          return .success(decoded.value)
====1
1:105,107c
      static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> [T]? {
          if source is NSNull {
              return nil
2:157,164c
3:157,164c
      static func decodeOptional<T>(clazz: T.Type, source: AnyObject?) -> Decoded<T?> {
          if let source = source, !(source is NSNull) {
              switch Decoders.decode(clazz: clazz, source: source, instance: nil) {
              case let .success(value): return .success(value)
              case let .failure(error): return .failure(error)
              }
          } else {
              return .success(nil)
====1
1:109,110c
          return source.map { (someSource: AnyObject) -> [T] in
              Decoders.decode(clazz: clazz, source: someSource)
2:166,179c
3:166,179c
      }
  
      static func decodeOptional<T>(clazz: [T].Type, source: AnyObject?) -> Decoded<[T]?> {
          if let source = source as? [AnyObject] {
              var values = [T]()
              for sourceValue in source {
                  switch Decoders.decode(clazz: T.self, source: sourceValue, instance: nil) {
                  case let .success(value): values.append(value)
                  case let .failure(error): return .failure(error)
                  }
              }
              return .success(values)
          } else {
              return .success(nil)
====1
1:114,116c
      static func decodeOptional<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject?) -> [Key:T]? {
          if source is NSNull {
              return nil
2:183,194c
3:183,194c
      static func decodeOptional<T, Key: Hashable>(clazz: [Key:T].Type, source: AnyObject?) -> Decoded<[Key:T]?> {
          if let sourceDictionary = source as? [Key: AnyObject] {
              var dictionary = [Key:T]()
              for (key, value) in sourceDictionary {
                  switch Decoders.decode(clazz: T.self, source: value, instance: nil) {
                  case let .success(value): dictionary[key] = value
                  case let .failure(error): return .failure(error)
                  }
              }
              return .success(dictionary)
          } else {
              return .success(nil)
====1
1:118,119c
          return source.map { (someSource: AnyObject) -> [Key:T] in
              Decoders.decode(clazz: clazz, source: someSource)
2:196,206c
3:196,206c
      }
  
      static func decodeOptional<T: RawRepresentable, U: AnyObject where T.RawValue == U>(clazz: T, source: AnyObject) -> Decoded<T?> {
          if let value = source as? U {
              if let enumValue = T.init(rawValue: value) {
                  return .success(enumValue)
              } else {
                  return .failure(.typeMismatch(expected: "A value from the enumeration \(T.self)", actual: "\(value)"))
              }
          } else {
              return .failure(.typeMismatch(expected: "String", actual: String(describing: type(of: source))))
====1
1:122a
2:210c
3:210c
  
====1
1:137c
          Decoders.addDecoder(clazz: Date.self) { (source: AnyObject, instance: AnyObject?) -> Date in
2:225c
3:225c
          Decoders.addDecoder(clazz: Date.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Date> in
====1
1:141c
                          return date
2:229c
3:229c
                          return .success(date)
====1
1:145c
              if let sourceInt = source as? Int64 {
2:233c
3:233c
              if let sourceInt = source as? Int {
====1
1:147c
                  return Date(timeIntervalSince1970: Double(sourceInt / 1000) )
2:235,250c
3:235,250c
                  return .success(Date(timeIntervalSince1970: Double(sourceInt / 1000) ))
              }
              if source is String || source is Int {
                  return .failure(.parseError(message: "Could not decode date"))
              } else {
                  return .failure(.typeMismatch(expected: "String or Int", actual: "\(source)"))
              }
          }
  
          // Decoder for ISOFullDate
          Decoders.addDecoder(clazz: ISOFullDate.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ISOFullDate> in
              if let string = source as? String,
                 let isoDate = ISOFullDate.from(string: string) {
                  return .success(isoDate)
              } else {
              	return .failure(.typeMismatch(expected: "ISO date", actual: "\(source)"))
====1
1:149c
              fatalError("formatter failed to parse \(source)")
2:251a
3:251a
====1
1:152,155c
          // Decoder for [AdditionalPropertiesClass]
          Decoders.addDecoder(clazz: [AdditionalPropertiesClass].self) { (source: AnyObject, instance: AnyObject?) -> [AdditionalPropertiesClass] in
              return Decoders.decode(clazz: [AdditionalPropertiesClass].self, source: source)
          }
2:253a
3:253a
====1
1:157,163c
          Decoders.addDecoder(clazz: AdditionalPropertiesClass.self) { (source: AnyObject, instance: AnyObject?) -> AdditionalPropertiesClass in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? AdditionalPropertiesClass() : instance as! AdditionalPropertiesClass
              
              result.mapProperty = Decoders.decodeOptional(clazz: Dictionary.self, source: sourceDictionary["map_property"] as AnyObject?)
              result.mapOfMapProperty = Decoders.decodeOptional(clazz: Dictionary.self, source: sourceDictionary["map_of_map_property"] as AnyObject?)
              return result
2:255,273c
3:255,273c
          Decoders.addDecoder(clazz: AdditionalPropertiesClass.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<AdditionalPropertiesClass> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? AdditionalPropertiesClass() : instance as! AdditionalPropertiesClass
                  switch Decoders.decodeOptional(clazz: [String:String].self, source: sourceDictionary["map_property"] as AnyObject?) {
                  
                  case let .success(value): result.mapProperty = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: [String:[String:String]].self, source: sourceDictionary["map_of_map_property"] as AnyObject?) {
                  
                  case let .success(value): result.mapOfMapProperty = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "AdditionalPropertiesClass", actual: "\(source)"))
              }
====1
1:167,170c
          // Decoder for [Animal]
          Decoders.addDecoder(clazz: [Animal].self) { (source: AnyObject, instance: AnyObject?) -> [Animal] in
              return Decoders.decode(clazz: [Animal].self, source: source)
          }
2:276a
3:276a
====1
1:172,176c
          Decoders.addDecoder(clazz: Animal.self) { (source: AnyObject, instance: AnyObject?) -> Animal in
              let sourceDictionary = source as! [AnyHashable: Any]
              // Check discriminator to support inheritance
              if let discriminator = sourceDictionary["className"] as? String, instance == nil && discriminator != "Animal" {
                  return Decoders.decode(clazz: Animal.self, discriminator: discriminator, source: source)
2:278,299c
3:278,299c
          Decoders.addDecoder(clazz: Animal.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Animal> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  // Check discriminator to support inheritance
                  if let discriminator = sourceDictionary["className"] as? String, instance == nil && discriminator != "Animal"{
                      return Decoders.decode(clazz: Animal.self, discriminator: discriminator, source: source)
                  }
                  let result = instance == nil ? Animal() : instance as! Animal
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["className"] as AnyObject?) {
                  
                  case let .success(value): result.className = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["color"] as AnyObject?) {
                  
                  case let .success(value): result.color = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "Animal", actual: "\(source)"))
====1
1:178,182c
              let result = instance == nil ? Animal() : instance as! Animal
              
              result.className = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["className"] as AnyObject?)
              result.color = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["color"] as AnyObject?)
              return result
2:300a
3:300a
====1
1:186,194c
          // Decoder for [AnimalFarm]
          Decoders.addDecoder(clazz: [AnimalFarm].self) { (source: AnyObject, instance: AnyObject?) -> [AnimalFarm] in
              return Decoders.decode(clazz: [AnimalFarm].self, source: source)
          }
          // Decoder for AnimalFarm
          Decoders.addDecoder(clazz: AnimalFarm.self) { (source: AnyObject, instance: AnyObject?) -> AnimalFarm in
              let sourceArray = source as! [AnyObject]
              return sourceArray.map({ Decoders.decode(clazz: Animal.self, source: $0, instance: nil) })
          }
2:303a
3:303a
====1
1:197,200c
          // Decoder for [ApiResponse]
          Decoders.addDecoder(clazz: [ApiResponse].self) { (source: AnyObject, instance: AnyObject?) -> [ApiResponse] in
              return Decoders.decode(clazz: [ApiResponse].self, source: source)
          }
2:306c
3:306c
  
====1
1:202,209c
          Decoders.addDecoder(clazz: ApiResponse.self) { (source: AnyObject, instance: AnyObject?) -> ApiResponse in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? ApiResponse() : instance as! ApiResponse
              
              result.code = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["code"] as AnyObject?)
              result.type = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?)
              result.message = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?)
              return result
2:308,332c
3:308,332c
          Decoders.addDecoder(clazz: ApiResponse.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ApiResponse> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? ApiResponse() : instance as! ApiResponse
                  switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["code"] as AnyObject?) {
                  
                  case let .success(value): result.code = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["type"] as AnyObject?) {
                  
                  case let .success(value): result.type = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["message"] as AnyObject?) {
                  
                  case let .success(value): result.message = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "ApiResponse", actual: "\(source)"))
              }
====1
1:213,216c
          // Decoder for [ArrayOfArrayOfNumberOnly]
          Decoders.addDecoder(clazz: [ArrayOfArrayOfNumberOnly].self) { (source: AnyObject, instance: AnyObject?) -> [ArrayOfArrayOfNumberOnly] in
              return Decoders.decode(clazz: [ArrayOfArrayOfNumberOnly].self, source: source)
          }
2:335a
3:335a
====1
1:218,223c
          Decoders.addDecoder(clazz: ArrayOfArrayOfNumberOnly.self) { (source: AnyObject, instance: AnyObject?) -> ArrayOfArrayOfNumberOnly in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? ArrayOfArrayOfNumberOnly() : instance as! ArrayOfArrayOfNumberOnly
              
              result.arrayArrayNumber = Decoders.decodeOptional(clazz: Array.self, source: sourceDictionary["ArrayArrayNumber"] as AnyObject?)
              return result
2:337,349c
3:337,349c
          Decoders.addDecoder(clazz: ArrayOfArrayOfNumberOnly.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ArrayOfArrayOfNumberOnly> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? ArrayOfArrayOfNumberOnly() : instance as! ArrayOfArrayOfNumberOnly
                  switch Decoders.decodeOptional(clazz: [[Double]].self, source: sourceDictionary["ArrayArrayNumber"] as AnyObject?) {
                  
                  case let .success(value): result.arrayArrayNumber = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "ArrayOfArrayOfNumberOnly", actual: "\(source)"))
              }
====1
1:227,230c
          // Decoder for [ArrayOfNumberOnly]
          Decoders.addDecoder(clazz: [ArrayOfNumberOnly].self) { (source: AnyObject, instance: AnyObject?) -> [ArrayOfNumberOnly] in
              return Decoders.decode(clazz: [ArrayOfNumberOnly].self, source: source)
          }
2:352a
3:352a
====1
1:232,237c
          Decoders.addDecoder(clazz: ArrayOfNumberOnly.self) { (source: AnyObject, instance: AnyObject?) -> ArrayOfNumberOnly in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? ArrayOfNumberOnly() : instance as! ArrayOfNumberOnly
              
              result.arrayNumber = Decoders.decodeOptional(clazz: Array.self, source: sourceDictionary["ArrayNumber"] as AnyObject?)
              return result
2:354,366c
3:354,366c
          Decoders.addDecoder(clazz: ArrayOfNumberOnly.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ArrayOfNumberOnly> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? ArrayOfNumberOnly() : instance as! ArrayOfNumberOnly
                  switch Decoders.decodeOptional(clazz: [Double].self, source: sourceDictionary["ArrayNumber"] as AnyObject?) {
                  
                  case let .success(value): result.arrayNumber = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "ArrayOfNumberOnly", actual: "\(source)"))
              }
====1
1:241,244c
          // Decoder for [ArrayTest]
          Decoders.addDecoder(clazz: [ArrayTest].self) { (source: AnyObject, instance: AnyObject?) -> [ArrayTest] in
              return Decoders.decode(clazz: [ArrayTest].self, source: source)
          }
2:369a
3:369a
====1
1:246,253c
          Decoders.addDecoder(clazz: ArrayTest.self) { (source: AnyObject, instance: AnyObject?) -> ArrayTest in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? ArrayTest() : instance as! ArrayTest
              
              result.arrayOfString = Decoders.decodeOptional(clazz: Array.self, source: sourceDictionary["array_of_string"] as AnyObject?)
              result.arrayArrayOfInteger = Decoders.decodeOptional(clazz: Array.self, source: sourceDictionary["array_array_of_integer"] as AnyObject?)
              result.arrayArrayOfModel = Decoders.decodeOptional(clazz: Array.self, source: sourceDictionary["array_array_of_model"] as AnyObject?)
              return result
2:371,395c
3:371,395c
          Decoders.addDecoder(clazz: ArrayTest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ArrayTest> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? ArrayTest() : instance as! ArrayTest
                  switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["array_of_string"] as AnyObject?) {
                  
                  case let .success(value): result.arrayOfString = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: [[Int64]].self, source: sourceDictionary["array_array_of_integer"] as AnyObject?) {
                  
                  case let .success(value): result.arrayArrayOfInteger = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: [[ReadOnlyFirst]].self, source: sourceDictionary["array_array_of_model"] as AnyObject?) {
                  
                  case let .success(value): result.arrayArrayOfModel = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "ArrayTest", actual: "\(source)"))
              }
====1
1:257,260c
          // Decoder for [Capitalization]
          Decoders.addDecoder(clazz: [Capitalization].self) { (source: AnyObject, instance: AnyObject?) -> [Capitalization] in
              return Decoders.decode(clazz: [Capitalization].self, source: source)
          }
2:398a
3:398a
====1
1:262,272c
          Decoders.addDecoder(clazz: Capitalization.self) { (source: AnyObject, instance: AnyObject?) -> Capitalization in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Capitalization() : instance as! Capitalization
              
              result.smallCamel = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["smallCamel"] as AnyObject?)
              result.capitalCamel = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["CapitalCamel"] as AnyObject?)
              result.smallSnake = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["small_Snake"] as AnyObject?)
              result.capitalSnake = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Capital_Snake"] as AnyObject?)
              result.sCAETHFlowPoints = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["SCA_ETH_Flow_Points"] as AnyObject?)
              result.ATT_NAME = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ATT_NAME"] as AnyObject?)
              return result
2:400,442c
3:400,442c
          Decoders.addDecoder(clazz: Capitalization.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Capitalization> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? Capitalization() : instance as! Capitalization
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["smallCamel"] as AnyObject?) {
                  
                  case let .success(value): result.smallCamel = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["CapitalCamel"] as AnyObject?) {
                  
                  case let .success(value): result.capitalCamel = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["small_Snake"] as AnyObject?) {
                  
                  case let .success(value): result.smallSnake = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["Capital_Snake"] as AnyObject?) {
                  
                  case let .success(value): result.capitalSnake = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["SCA_ETH_Flow_Points"] as AnyObject?) {
                  
                  case let .success(value): result.sCAETHFlowPoints = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["ATT_NAME"] as AnyObject?) {
                  
                  case let .success(value): result.ATT_NAME = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "Capitalization", actual: "\(source)"))
              }
====1
1:276,279c
          // Decoder for [Cat]
          Decoders.addDecoder(clazz: [Cat].self) { (source: AnyObject, instance: AnyObject?) -> [Cat] in
              return Decoders.decode(clazz: [Cat].self, source: source)
          }
2:445a
3:445a
====1
1:281,291c
          Decoders.addDecoder(clazz: Cat.self) { (source: AnyObject, instance: AnyObject?) -> Cat in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Cat() : instance as! Cat
              if decoders["\(Animal.self)"] != nil {
                _ = Decoders.decode(clazz: Animal.self, source: source, instance: result)
              }
              
              result.className = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["className"] as AnyObject?)
              result.color = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["color"] as AnyObject?)
              result.declawed = Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["declawed"] as AnyObject?)
              return result
2:447,474c
3:447,474c
          Decoders.addDecoder(clazz: Cat.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Cat> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? Cat() : instance as! Cat
                  if decoders["\(Animal.self)"] != nil {
                    _ = Decoders.decode(clazz: Animal.self, source: source, instance: result)
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["className"] as AnyObject?) {
                  
                  case let .success(value): result.className = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["color"] as AnyObject?) {
                  
                  case let .success(value): result.color = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["declawed"] as AnyObject?) {
                  
                  case let .success(value): result.declawed = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "Cat", actual: "\(source)"))
              }
====1
1:295,298c
          // Decoder for [Category]
          Decoders.addDecoder(clazz: [Category].self) { (source: AnyObject, instance: AnyObject?) -> [Category] in
              return Decoders.decode(clazz: [Category].self, source: source)
          }
2:477a
3:477a
====1
1:300,306c
          Decoders.addDecoder(clazz: Category.self) { (source: AnyObject, instance: AnyObject?) -> Category in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Category() : instance as! Category
              
              result.id = Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?)
              result.name = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?)
              return result
2:479,497c
3:479,497c
          Decoders.addDecoder(clazz: Category.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Category> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? Category() : instance as! Category
                  switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                  
                  case let .success(value): result.id = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                  
                  case let .success(value): result.name = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "Category", actual: "\(source)"))
              }
====1
1:310,313c
          // Decoder for [ClassModel]
          Decoders.addDecoder(clazz: [ClassModel].self) { (source: AnyObject, instance: AnyObject?) -> [ClassModel] in
              return Decoders.decode(clazz: [ClassModel].self, source: source)
          }
2:500a
3:500a
====1
1:315,320c
          Decoders.addDecoder(clazz: ClassModel.self) { (source: AnyObject, instance: AnyObject?) -> ClassModel in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? ClassModel() : instance as! ClassModel
              
              result._class = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?)
              return result
2:502,514c
3:502,514c
          Decoders.addDecoder(clazz: ClassModel.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ClassModel> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? ClassModel() : instance as! ClassModel
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["_class"] as AnyObject?) {
                  
                  case let .success(value): result._class = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "ClassModel", actual: "\(source)"))
              }
====1
1:324,327c
          // Decoder for [Client]
          Decoders.addDecoder(clazz: [Client].self) { (source: AnyObject, instance: AnyObject?) -> [Client] in
              return Decoders.decode(clazz: [Client].self, source: source)
          }
2:517a
3:517a
====1
1:329,334c
          Decoders.addDecoder(clazz: Client.self) { (source: AnyObject, instance: AnyObject?) -> Client in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Client() : instance as! Client
              
              result.client = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["client"] as AnyObject?)
              return result
2:519,531c
3:519,531c
          Decoders.addDecoder(clazz: Client.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Client> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? Client() : instance as! Client
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["client"] as AnyObject?) {
                  
                  case let .success(value): result.client = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "Client", actual: "\(source)"))
              }
====1
1:338,341c
          // Decoder for [Dog]
          Decoders.addDecoder(clazz: [Dog].self) { (source: AnyObject, instance: AnyObject?) -> [Dog] in
              return Decoders.decode(clazz: [Dog].self, source: source)
          }
2:534a
3:534a
====1
1:343,353c
          Decoders.addDecoder(clazz: Dog.self) { (source: AnyObject, instance: AnyObject?) -> Dog in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Dog() : instance as! Dog
              if decoders["\(Animal.self)"] != nil {
                _ = Decoders.decode(clazz: Animal.self, source: source, instance: result)
              }
              
              result.className = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["className"] as AnyObject?)
              result.color = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["color"] as AnyObject?)
              result.breed = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["breed"] as AnyObject?)
              return result
2:536,563c
3:536,563c
          Decoders.addDecoder(clazz: Dog.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Dog> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? Dog() : instance as! Dog
                  if decoders["\(Animal.self)"] != nil {
                    _ = Decoders.decode(clazz: Animal.self, source: source, instance: result)
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["className"] as AnyObject?) {
                  
                  case let .success(value): result.className = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["color"] as AnyObject?) {
                  
                  case let .success(value): result.color = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["breed"] as AnyObject?) {
                  
                  case let .success(value): result.breed = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "Dog", actual: "\(source)"))
              }
====1
1:357,360c
          // Decoder for [EnumArrays]
          Decoders.addDecoder(clazz: [EnumArrays].self) { (source: AnyObject, instance: AnyObject?) -> [EnumArrays] in
              return Decoders.decode(clazz: [EnumArrays].self, source: source)
          }
2:566a
3:566a
====1
1:362,371c
          Decoders.addDecoder(clazz: EnumArrays.self) { (source: AnyObject, instance: AnyObject?) -> EnumArrays in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? EnumArrays() : instance as! EnumArrays
              
              if let justSymbol = sourceDictionary["just_symbol"] as? String { 
                  result.justSymbol = EnumArrays.JustSymbol(rawValue: (justSymbol))
              }
              
              if let arrayEnum = sourceDictionary["array_enum"] as? [String] { 
                  result.arrayEnum  = arrayEnum.map ({ EnumArrays.ArrayEnum(rawValue: $0)! })
2:568,585c
3:568,585c
          Decoders.addDecoder(clazz: EnumArrays.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EnumArrays> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? EnumArrays() : instance as! EnumArrays
                  switch Decoders.decodeOptional(clazz: EnumArrays.JustSymbol.self, source: sourceDictionary["just_symbol"] as AnyObject?) {
                  
                  case let .success(value): result.justSymbol = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Array<EnumArrays.ArrayEnum>.self, source: sourceDictionary["array_enum"] as AnyObject?) {
                  
                  case let .success(value): result.arrayEnum = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "EnumArrays", actual: "\(source)"))
====1
1:373,374c
              
              return result
2:586a
3:586a
====1
1:378,381c
          // Decoder for [EnumClass]
          Decoders.addDecoder(clazz: [EnumClass].self) { (source: AnyObject, instance: AnyObject?) -> [EnumClass] in
              return Decoders.decode(clazz: [EnumClass].self, source: source)
          }
2:589a
3:589a
====1
1:383,389c
          Decoders.addDecoder(clazz: EnumClass.self) { (source: AnyObject, instance: AnyObject?) -> EnumClass in
              if let source = source as? String {
                  if let result = EnumClass(rawValue: source) {
                      return result
                  }
              }
              fatalError("Source \(source) is not convertible to enum type EnumClass: Maybe swagger file is insufficient")
2:591,593c
3:591,593c
          Decoders.addDecoder(clazz: EnumClass.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EnumClass> in
              //TODO: I don't think we need this anymore
              return Decoders.decode(clazz: EnumClass.self, source: source, instance: instance)
====1
1:393,396c
          // Decoder for [EnumTest]
          Decoders.addDecoder(clazz: [EnumTest].self) { (source: AnyObject, instance: AnyObject?) -> [EnumTest] in
              return Decoders.decode(clazz: [EnumTest].self, source: source)
          }
2:596a
3:596a
====
1:398,415c
          Decoders.addDecoder(clazz: EnumTest.self) { (source: AnyObject, instance: AnyObject?) -> EnumTest in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? EnumTest() : instance as! EnumTest
              
              if let enumString = sourceDictionary["enum_string"] as? String { 
                  result.enumString = EnumTest.EnumString(rawValue: (enumString))
              }
              
              if let enumInteger = sourceDictionary["enum_integer"] as? Int32 { 
                  result.enumInteger = EnumTest.EnumInteger(rawValue: (enumInteger))
              }
              
              if let enumNumber = sourceDictionary["enum_number"] as? Double { 
                  result.enumNumber = EnumTest.EnumNumber(rawValue: (enumNumber))
              }
              
              result.outerEnum = Decoders.decodeOptional(clazz: OuterEnum.self, source: sourceDictionary["outerEnum"] as AnyObject?)
              return result
2:598,1062c
  <<<<<<< HEAD
          Decoders.addDecoder(clazz: EnumTest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EnumTest> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? EnumTest() : instance as! EnumTest
                  switch Decoders.decodeOptional(clazz: EnumTest.EnumString.self, source: sourceDictionary["enum_string"] as AnyObject?) {
                  
                  case let .success(value): result.enumString = value
                  case let .failure(error): return .failure(error)
                  
  ||||||| 4479382ced
          Decoders.addDecoder(clazz: EnumTest.self) { (source: AnyObject, instance: AnyObject?) -> EnumTest in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? EnumTest() : instance as! EnumTest
              
              if let enumString = sourceDictionary["enum_string"] as? String { 
                  result.enumString = EnumTest.EnumString(rawValue: (enumString))
              }
              
              if let enumInteger = sourceDictionary["enum_integer"] as? Int32 { 
                  result.enumInteger = EnumTest.EnumInteger(rawValue: (enumInteger))
              }
              
              if let enumNumber = sourceDictionary["enum_number"] as? Double { 
                  result.enumNumber = EnumTest.EnumNumber(rawValue: (enumNumber))
              }
              
              result.outerEnum = Decoders.decodeOptional(clazz: OuterEnum.self, source: sourceDictionary["outerEnum"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [FormatTest]
          Decoders.addDecoder(clazz: [FormatTest].self) { (source: AnyObject, instance: AnyObject?) -> [FormatTest] in
              return Decoders.decode(clazz: [FormatTest].self, source: source)
          }
          // Decoder for FormatTest
          Decoders.addDecoder(clazz: FormatTest.self) { (source: AnyObject, instance: AnyObject?) -> FormatTest in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? FormatTest() : instance as! FormatTest
              
              result.integer = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["integer"] as AnyObject?)
              result.int32 = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["int32"] as AnyObject?)
              result.int64 = Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["int64"] as AnyObject?)
              result.number = Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["number"] as AnyObject?)
              result.float = Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["float"] as AnyObject?)
              result.double = Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["double"] as AnyObject?)
              result.string = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["string"] as AnyObject?)
              result.byte = Decoders.decodeOptional(clazz: Data.self, source: sourceDictionary["byte"] as AnyObject?)
              result.binary = Decoders.decodeOptional(clazz: Data.self, source: sourceDictionary["binary"] as AnyObject?)
              result.date = Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["date"] as AnyObject?)
              result.dateTime = Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["dateTime"] as AnyObject?)
              result.uuid = Decoders.decodeOptional(clazz: UUID.self, source: sourceDictionary["uuid"] as AnyObject?)
              result.password = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [HasOnlyReadOnly]
          Decoders.addDecoder(clazz: [HasOnlyReadOnly].self) { (source: AnyObject, instance: AnyObject?) -> [HasOnlyReadOnly] in
              return Decoders.decode(clazz: [HasOnlyReadOnly].self, source: source)
          }
          // Decoder for HasOnlyReadOnly
          Decoders.addDecoder(clazz: HasOnlyReadOnly.self) { (source: AnyObject, instance: AnyObject?) -> HasOnlyReadOnly in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? HasOnlyReadOnly() : instance as! HasOnlyReadOnly
              
              result.bar = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bar"] as AnyObject?)
              result.foo = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["foo"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [List]
          Decoders.addDecoder(clazz: [List].self) { (source: AnyObject, instance: AnyObject?) -> [List] in
              return Decoders.decode(clazz: [List].self, source: source)
          }
          // Decoder for List
          Decoders.addDecoder(clazz: List.self) { (source: AnyObject, instance: AnyObject?) -> List in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? List() : instance as! List
              
              result._123List = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["123-list"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [MapTest]
          Decoders.addDecoder(clazz: [MapTest].self) { (source: AnyObject, instance: AnyObject?) -> [MapTest] in
              return Decoders.decode(clazz: [MapTest].self, source: source)
          }
          // Decoder for MapTest
          Decoders.addDecoder(clazz: MapTest.self) { (source: AnyObject, instance: AnyObject?) -> MapTest in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? MapTest() : instance as! MapTest
              
              result.mapMapOfString = Decoders.decodeOptional(clazz: Dictionary.self, source: sourceDictionary["map_map_of_string"] as AnyObject?)
              if let mapOfEnumString = sourceDictionary["map_of_enum_string"] as? [String:String] { //TODO: handle enum map scenario
              }
              
              return result
          }
  
  
          // Decoder for [MixedPropertiesAndAdditionalPropertiesClass]
          Decoders.addDecoder(clazz: [MixedPropertiesAndAdditionalPropertiesClass].self) { (source: AnyObject, instance: AnyObject?) -> [MixedPropertiesAndAdditionalPropertiesClass] in
              return Decoders.decode(clazz: [MixedPropertiesAndAdditionalPropertiesClass].self, source: source)
          }
          // Decoder for MixedPropertiesAndAdditionalPropertiesClass
          Decoders.addDecoder(clazz: MixedPropertiesAndAdditionalPropertiesClass.self) { (source: AnyObject, instance: AnyObject?) -> MixedPropertiesAndAdditionalPropertiesClass in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? MixedPropertiesAndAdditionalPropertiesClass() : instance as! MixedPropertiesAndAdditionalPropertiesClass
              
              result.uuid = Decoders.decodeOptional(clazz: UUID.self, source: sourceDictionary["uuid"] as AnyObject?)
              result.dateTime = Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["dateTime"] as AnyObject?)
              result.map = Decoders.decodeOptional(clazz: Dictionary.self, source: sourceDictionary["map"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [Model200Response]
          Decoders.addDecoder(clazz: [Model200Response].self) { (source: AnyObject, instance: AnyObject?) -> [Model200Response] in
              return Decoders.decode(clazz: [Model200Response].self, source: source)
          }
          // Decoder for Model200Response
          Decoders.addDecoder(clazz: Model200Response.self) { (source: AnyObject, instance: AnyObject?) -> Model200Response in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Model200Response() : instance as! Model200Response
              
              result.name = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["name"] as AnyObject?)
              result._class = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["class"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [Name]
          Decoders.addDecoder(clazz: [Name].self) { (source: AnyObject, instance: AnyObject?) -> [Name] in
              return Decoders.decode(clazz: [Name].self, source: source)
          }
          // Decoder for Name
          Decoders.addDecoder(clazz: Name.self) { (source: AnyObject, instance: AnyObject?) -> Name in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Name() : instance as! Name
              
              result.name = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["name"] as AnyObject?)
              result.snakeCase = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["snake_case"] as AnyObject?)
              result.property = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["property"] as AnyObject?)
              result._123Number = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["123Number"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [NumberOnly]
          Decoders.addDecoder(clazz: [NumberOnly].self) { (source: AnyObject, instance: AnyObject?) -> [NumberOnly] in
              return Decoders.decode(clazz: [NumberOnly].self, source: source)
          }
          // Decoder for NumberOnly
          Decoders.addDecoder(clazz: NumberOnly.self) { (source: AnyObject, instance: AnyObject?) -> NumberOnly in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? NumberOnly() : instance as! NumberOnly
              
              result.justNumber = Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["JustNumber"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [Order]
          Decoders.addDecoder(clazz: [Order].self) { (source: AnyObject, instance: AnyObject?) -> [Order] in
              return Decoders.decode(clazz: [Order].self, source: source)
          }
          // Decoder for Order
          Decoders.addDecoder(clazz: Order.self) { (source: AnyObject, instance: AnyObject?) -> Order in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Order() : instance as! Order
              
              result.id = Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?)
              result.petId = Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["petId"] as AnyObject?)
              result.quantity = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["quantity"] as AnyObject?)
              result.shipDate = Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["shipDate"] as AnyObject?)
              if let status = sourceDictionary["status"] as? String { 
                  result.status = Order.Status(rawValue: (status))
              }
              
              result.complete = Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["complete"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [OuterBoolean]
          Decoders.addDecoder(clazz: [OuterBoolean].self) { (source: AnyObject) -> [OuterBoolean] in
              return Decoders.decode(clazz: [OuterBoolean].self, source: source)
          }
          // Decoder for OuterBoolean
          Decoders.addDecoder(clazz: OuterBoolean.self) { (source: AnyObject) -> OuterBoolean in
              if let source = source as? Bool {
                  return source
              }
              fatalError("Source \(source) is not convertible to typealias OuterBoolean: Maybe swagger file is insufficient")
          }
  
  
          // Decoder for [OuterComposite]
          Decoders.addDecoder(clazz: [OuterComposite].self) { (source: AnyObject) -> [OuterComposite] in
              return Decoders.decode(clazz: [OuterComposite].self, source: source)
          }
          // Decoder for OuterComposite
          Decoders.addDecoder(clazz: OuterComposite.self) { (source: AnyObject) -> OuterComposite in
              let sourceDictionary = source as! [AnyHashable: Any]
  
              let instance = OuterComposite()
              instance.myNumber = Decoders.decodeOptional(clazz: OuterNumber.self, source: sourceDictionary["my_number"] as AnyObject?)
              instance.myString = Decoders.decodeOptional(clazz: OuterString.self, source: sourceDictionary["my_string"] as AnyObject?)
              instance.myBoolean = Decoders.decodeOptional(clazz: OuterBoolean.self, source: sourceDictionary["my_boolean"] as AnyObject?)
              return instance
          }
  
  
          // Decoder for [OuterEnum]
          Decoders.addDecoder(clazz: [OuterEnum].self) { (source: AnyObject, instance: AnyObject?) -> [OuterEnum] in
              return Decoders.decode(clazz: [OuterEnum].self, source: source)
          }
          // Decoder for OuterEnum
          Decoders.addDecoder(clazz: OuterEnum.self) { (source: AnyObject, instance: AnyObject?) -> OuterEnum in
              if let source = source as? String {
                  if let result = OuterEnum(rawValue: source) {
                      return result
  =======
          Decoders.addDecoder(clazz: EnumTest.self) { (source: AnyObject, instance: AnyObject?) -> EnumTest in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? EnumTest() : instance as! EnumTest
              
              if let enumString = sourceDictionary["enum_string"] as? String { 
                  result.enumString = EnumTest.EnumString(rawValue: (enumString))
              }
              
              if let enumInteger = sourceDictionary["enum_integer"] as? Int32 { 
                  result.enumInteger = EnumTest.EnumInteger(rawValue: (enumInteger))
              }
              
              if let enumNumber = sourceDictionary["enum_number"] as? Double { 
                  result.enumNumber = EnumTest.EnumNumber(rawValue: (enumNumber))
              }
              
              result.outerEnum = Decoders.decodeOptional(clazz: OuterEnum.self, source: sourceDictionary["outerEnum"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [FormatTest]
          Decoders.addDecoder(clazz: [FormatTest].self) { (source: AnyObject, instance: AnyObject?) -> [FormatTest] in
              return Decoders.decode(clazz: [FormatTest].self, source: source)
          }
          // Decoder for FormatTest
          Decoders.addDecoder(clazz: FormatTest.self) { (source: AnyObject, instance: AnyObject?) -> FormatTest in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? FormatTest() : instance as! FormatTest
              
              result.integer = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["integer"] as AnyObject?)
              result.int32 = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["int32"] as AnyObject?)
              result.int64 = Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["int64"] as AnyObject?)
              result.number = Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["number"] as AnyObject?)
              result.float = Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["float"] as AnyObject?)
              result.double = Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["double"] as AnyObject?)
              result.string = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["string"] as AnyObject?)
              result.byte = Decoders.decodeOptional(clazz: Data.self, source: sourceDictionary["byte"] as AnyObject?)
              result.binary = Decoders.decodeOptional(clazz: Data.self, source: sourceDictionary["binary"] as AnyObject?)
              result.date = Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["date"] as AnyObject?)
              result.dateTime = Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["dateTime"] as AnyObject?)
              result.uuid = Decoders.decodeOptional(clazz: UUID.self, source: sourceDictionary["uuid"] as AnyObject?)
              result.password = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [HasOnlyReadOnly]
          Decoders.addDecoder(clazz: [HasOnlyReadOnly].self) { (source: AnyObject, instance: AnyObject?) -> [HasOnlyReadOnly] in
              return Decoders.decode(clazz: [HasOnlyReadOnly].self, source: source)
          }
          // Decoder for HasOnlyReadOnly
          Decoders.addDecoder(clazz: HasOnlyReadOnly.self) { (source: AnyObject, instance: AnyObject?) -> HasOnlyReadOnly in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? HasOnlyReadOnly() : instance as! HasOnlyReadOnly
              
              result.bar = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bar"] as AnyObject?)
              result.foo = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["foo"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [List]
          Decoders.addDecoder(clazz: [List].self) { (source: AnyObject, instance: AnyObject?) -> [List] in
              return Decoders.decode(clazz: [List].self, source: source)
          }
          // Decoder for List
          Decoders.addDecoder(clazz: List.self) { (source: AnyObject, instance: AnyObject?) -> List in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? List() : instance as! List
              
              result._123List = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["123-list"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [MapTest]
          Decoders.addDecoder(clazz: [MapTest].self) { (source: AnyObject, instance: AnyObject?) -> [MapTest] in
              return Decoders.decode(clazz: [MapTest].self, source: source)
          }
          // Decoder for MapTest
          Decoders.addDecoder(clazz: MapTest.self) { (source: AnyObject, instance: AnyObject?) -> MapTest in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? MapTest() : instance as! MapTest
              
              result.mapMapOfString = Decoders.decodeOptional(clazz: Dictionary.self, source: sourceDictionary["map_map_of_string"] as AnyObject?)
              if let mapOfEnumString = sourceDictionary["map_of_enum_string"] as? [String:String] { //TODO: handle enum map scenario
              }
              
              return result
          }
  
  
          // Decoder for [MixedPropertiesAndAdditionalPropertiesClass]
          Decoders.addDecoder(clazz: [MixedPropertiesAndAdditionalPropertiesClass].self) { (source: AnyObject, instance: AnyObject?) -> [MixedPropertiesAndAdditionalPropertiesClass] in
              return Decoders.decode(clazz: [MixedPropertiesAndAdditionalPropertiesClass].self, source: source)
          }
          // Decoder for MixedPropertiesAndAdditionalPropertiesClass
          Decoders.addDecoder(clazz: MixedPropertiesAndAdditionalPropertiesClass.self) { (source: AnyObject, instance: AnyObject?) -> MixedPropertiesAndAdditionalPropertiesClass in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? MixedPropertiesAndAdditionalPropertiesClass() : instance as! MixedPropertiesAndAdditionalPropertiesClass
              
              result.uuid = Decoders.decodeOptional(clazz: UUID.self, source: sourceDictionary["uuid"] as AnyObject?)
              result.dateTime = Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["dateTime"] as AnyObject?)
              result.map = Decoders.decodeOptional(clazz: Dictionary.self, source: sourceDictionary["map"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [Model200Response]
          Decoders.addDecoder(clazz: [Model200Response].self) { (source: AnyObject, instance: AnyObject?) -> [Model200Response] in
              return Decoders.decode(clazz: [Model200Response].self, source: source)
          }
          // Decoder for Model200Response
          Decoders.addDecoder(clazz: Model200Response.self) { (source: AnyObject, instance: AnyObject?) -> Model200Response in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Model200Response() : instance as! Model200Response
              
              result.name = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["name"] as AnyObject?)
              result._class = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["class"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [Name]
          Decoders.addDecoder(clazz: [Name].self) { (source: AnyObject, instance: AnyObject?) -> [Name] in
              return Decoders.decode(clazz: [Name].self, source: source)
          }
          // Decoder for Name
          Decoders.addDecoder(clazz: Name.self) { (source: AnyObject, instance: AnyObject?) -> Name in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Name() : instance as! Name
              
              result.name = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["name"] as AnyObject?)
              result.snakeCase = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["snake_case"] as AnyObject?)
              result.property = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["property"] as AnyObject?)
              result._123Number = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["123Number"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [NumberOnly]
          Decoders.addDecoder(clazz: [NumberOnly].self) { (source: AnyObject, instance: AnyObject?) -> [NumberOnly] in
              return Decoders.decode(clazz: [NumberOnly].self, source: source)
          }
          // Decoder for NumberOnly
          Decoders.addDecoder(clazz: NumberOnly.self) { (source: AnyObject, instance: AnyObject?) -> NumberOnly in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? NumberOnly() : instance as! NumberOnly
              
              result.justNumber = Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["JustNumber"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [Order]
          Decoders.addDecoder(clazz: [Order].self) { (source: AnyObject, instance: AnyObject?) -> [Order] in
              return Decoders.decode(clazz: [Order].self, source: source)
          }
          // Decoder for Order
          Decoders.addDecoder(clazz: Order.self) { (source: AnyObject, instance: AnyObject?) -> Order in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Order() : instance as! Order
              
              result.id = Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?)
              result.petId = Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["petId"] as AnyObject?)
              result.quantity = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["quantity"] as AnyObject?)
              result.shipDate = Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["shipDate"] as AnyObject?)
              if let status = sourceDictionary["status"] as? String { 
                  result.status = Order.Status(rawValue: (status))
              }
              
              result.complete = Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["complete"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [OuterBoolean]
          Decoders.addDecoder(clazz: [OuterBoolean].self) { (source: AnyObject, instance: AnyObject?) -> [OuterBoolean] in
              return Decoders.decode(clazz: [OuterBoolean].self, source: source)
          }
          // Decoder for OuterBoolean
          Decoders.addDecoder(clazz: OuterBoolean.self) { (source: AnyObject, instance: AnyObject?) -> OuterBoolean in
              if let source = source as? Bool {
                  return source
              }
              fatalError("Source \(source) is not convertible to typealias OuterBoolean: Maybe swagger file is insufficient")
          }
  
  
          // Decoder for [OuterComposite]
          Decoders.addDecoder(clazz: [OuterComposite].self) { (source: AnyObject, instance: AnyObject?) -> [OuterComposite] in
              return Decoders.decode(clazz: [OuterComposite].self, source: source)
          }
          // Decoder for OuterComposite
          Decoders.addDecoder(clazz: OuterComposite.self) { (source: AnyObject, instance: AnyObject?) -> OuterComposite in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? OuterComposite() : instance as! OuterComposite
              
              result.myNumber = Decoders.decodeOptional(clazz: OuterNumber.self, source: sourceDictionary["my_number"] as AnyObject?)
              result.myString = Decoders.decodeOptional(clazz: OuterString.self, source: sourceDictionary["my_string"] as AnyObject?)
              result.myBoolean = Decoders.decodeOptional(clazz: OuterBoolean.self, source: sourceDictionary["my_boolean"] as AnyObject?)
              return result
          }
  
  
          // Decoder for [OuterEnum]
          Decoders.addDecoder(clazz: [OuterEnum].self) { (source: AnyObject, instance: AnyObject?) -> [OuterEnum] in
              return Decoders.decode(clazz: [OuterEnum].self, source: source)
          }
          // Decoder for OuterEnum
          Decoders.addDecoder(clazz: OuterEnum.self) { (source: AnyObject, instance: AnyObject?) -> OuterEnum in
              if let source = source as? String {
                  if let result = OuterEnum(rawValue: source) {
                      return result
  >>>>>>> TEMP_RIGHT_BRANCH
                  }
                  switch Decoders.decodeOptional(clazz: EnumTest.EnumInteger.self, source: sourceDictionary["enum_integer"] as AnyObject?) {
                  
                  case let .success(value): result.enumInteger = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: EnumTest.EnumNumber.self, source: sourceDictionary["enum_number"] as AnyObject?) {
                  
                  case let .success(value): result.enumNumber = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: OuterEnum.self, source: sourceDictionary["outerEnum"] as AnyObject?) {
                  
                  case let .success(value): result.outerEnum = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "EnumTest", actual: "\(source)"))
              }
3:598,628c
          Decoders.addDecoder(clazz: EnumTest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<EnumTest> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? EnumTest() : instance as! EnumTest
                  switch Decoders.decodeOptional(clazz: EnumTest.EnumString.self, source: sourceDictionary["enum_string"] as AnyObject?) {
                  
                  case let .success(value): result.enumString = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: EnumTest.EnumInteger.self, source: sourceDictionary["enum_integer"] as AnyObject?) {
                  
                  case let .success(value): result.enumInteger = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: EnumTest.EnumNumber.self, source: sourceDictionary["enum_number"] as AnyObject?) {
                  
                  case let .success(value): result.enumNumber = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: OuterEnum.self, source: sourceDictionary["outerEnum"] as AnyObject?) {
                  
                  case let .success(value): result.outerEnum = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "EnumTest", actual: "\(source)"))
              }
====
1:419,422c
          // Decoder for [FormatTest]
          Decoders.addDecoder(clazz: [FormatTest].self) { (source: AnyObject, instance: AnyObject?) -> [FormatTest] in
              return Decoders.decode(clazz: [FormatTest].self, source: source)
          }
2:1066c
  <<<<<<< HEAD
3:631a
====
1:424,441c
          Decoders.addDecoder(clazz: FormatTest.self) { (source: AnyObject, instance: AnyObject?) -> FormatTest in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? FormatTest() : instance as! FormatTest
              
              result.integer = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["integer"] as AnyObject?)
              result.int32 = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["int32"] as AnyObject?)
              result.int64 = Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["int64"] as AnyObject?)
              result.number = Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["number"] as AnyObject?)
              result.float = Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["float"] as AnyObject?)
              result.double = Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["double"] as AnyObject?)
              result.string = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["string"] as AnyObject?)
              result.byte = Decoders.decodeOptional(clazz: Data.self, source: sourceDictionary["byte"] as AnyObject?)
              result.binary = Decoders.decodeOptional(clazz: Data.self, source: sourceDictionary["binary"] as AnyObject?)
              result.date = Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["date"] as AnyObject?)
              result.dateTime = Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["dateTime"] as AnyObject?)
              result.uuid = Decoders.decodeOptional(clazz: UUID.self, source: sourceDictionary["uuid"] as AnyObject?)
              result.password = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?)
              return result
2:1068,1161c
          Decoders.addDecoder(clazz: FormatTest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormatTest> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? FormatTest() : instance as! FormatTest
                  switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["integer"] as AnyObject?) {
                  
                  case let .success(value): result.integer = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["int32"] as AnyObject?) {
                  
                  case let .success(value): result.int32 = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["int64"] as AnyObject?) {
                  
                  case let .success(value): result.int64 = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["number"] as AnyObject?) {
                  
                  case let .success(value): result.number = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["float"] as AnyObject?) {
                  
                  case let .success(value): result.float = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["double"] as AnyObject?) {
                  
                  case let .success(value): result.double = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["string"] as AnyObject?) {
                  
                  case let .success(value): result.string = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Data.self, source: sourceDictionary["byte"] as AnyObject?) {
                  
                  case let .success(value): result.byte = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Data.self, source: sourceDictionary["binary"] as AnyObject?) {
                  
                  case let .success(value): result.binary = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["date"] as AnyObject?) {
                  
                  case let .success(value): result.date = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["dateTime"] as AnyObject?) {
                  
                  case let .success(value): result.dateTime = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: UUID.self, source: sourceDictionary["uuid"] as AnyObject?) {
                  
                  case let .success(value): result.uuid = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                  
                  case let .success(value): result.password = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "FormatTest", actual: "\(source)"))
              }
  ||||||| 4479382ced
          // Decoder for [OuterNumber]
          Decoders.addDecoder(clazz: [OuterNumber].self) { (source: AnyObject) -> [OuterNumber] in
              return Decoders.decode(clazz: [OuterNumber].self, source: source)
  =======
          // Decoder for [OuterNumber]
          Decoders.addDecoder(clazz: [OuterNumber].self) { (source: AnyObject, instance: AnyObject?) -> [OuterNumber] in
              return Decoders.decode(clazz: [OuterNumber].self, source: source)
  >>>>>>> TEMP_RIGHT_BRANCH
3:633,717c
          Decoders.addDecoder(clazz: FormatTest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<FormatTest> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? FormatTest() : instance as! FormatTest
                  switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["integer"] as AnyObject?) {
                  
                  case let .success(value): result.integer = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["int32"] as AnyObject?) {
                  
                  case let .success(value): result.int32 = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["int64"] as AnyObject?) {
                  
                  case let .success(value): result.int64 = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["number"] as AnyObject?) {
                  
                  case let .success(value): result.number = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Float.self, source: sourceDictionary["float"] as AnyObject?) {
                  
                  case let .success(value): result.float = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["double"] as AnyObject?) {
                  
                  case let .success(value): result.double = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["string"] as AnyObject?) {
                  
                  case let .success(value): result.string = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Data.self, source: sourceDictionary["byte"] as AnyObject?) {
                  
                  case let .success(value): result.byte = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Data.self, source: sourceDictionary["binary"] as AnyObject?) {
                  
                  case let .success(value): result.binary = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: ISOFullDate.self, source: sourceDictionary["date"] as AnyObject?) {
                  
                  case let .success(value): result.date = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["dateTime"] as AnyObject?) {
                  
                  case let .success(value): result.dateTime = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: UUID.self, source: sourceDictionary["uuid"] as AnyObject?) {
                  
                  case let .success(value): result.uuid = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                  
                  case let .success(value): result.password = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "FormatTest", actual: "\(source)"))
              }
====1
1:445,448c
          // Decoder for [HasOnlyReadOnly]
          Decoders.addDecoder(clazz: [HasOnlyReadOnly].self) { (source: AnyObject, instance: AnyObject?) -> [HasOnlyReadOnly] in
              return Decoders.decode(clazz: [HasOnlyReadOnly].self, source: source)
          }
2:1164a
3:720a
====1
1:450,456c
          Decoders.addDecoder(clazz: HasOnlyReadOnly.self) { (source: AnyObject, instance: AnyObject?) -> HasOnlyReadOnly in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? HasOnlyReadOnly() : instance as! HasOnlyReadOnly
              
              result.bar = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bar"] as AnyObject?)
              result.foo = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["foo"] as AnyObject?)
              return result
2:1166,1184c
3:722,740c
          Decoders.addDecoder(clazz: HasOnlyReadOnly.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<HasOnlyReadOnly> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? HasOnlyReadOnly() : instance as! HasOnlyReadOnly
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bar"] as AnyObject?) {
                  
                  case let .success(value): result.bar = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["foo"] as AnyObject?) {
                  
                  case let .success(value): result.foo = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "HasOnlyReadOnly", actual: "\(source)"))
              }
====1
1:460,463c
          // Decoder for [List]
          Decoders.addDecoder(clazz: [List].self) { (source: AnyObject, instance: AnyObject?) -> [List] in
              return Decoders.decode(clazz: [List].self, source: source)
          }
2:1187a
3:743a
====1
1:465,470c
          Decoders.addDecoder(clazz: List.self) { (source: AnyObject, instance: AnyObject?) -> List in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? List() : instance as! List
              
              result._123List = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["123-list"] as AnyObject?)
              return result
2:1189,1201c
3:745,757c
          Decoders.addDecoder(clazz: List.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<List> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? List() : instance as! List
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["123-list"] as AnyObject?) {
                  
                  case let .success(value): result._123List = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "List", actual: "\(source)"))
              }
====1
1:474,477c
          // Decoder for [MapTest]
          Decoders.addDecoder(clazz: [MapTest].self) { (source: AnyObject, instance: AnyObject?) -> [MapTest] in
              return Decoders.decode(clazz: [MapTest].self, source: source)
          }
2:1204a
3:760a
====1
1:479,484c
          Decoders.addDecoder(clazz: MapTest.self) { (source: AnyObject, instance: AnyObject?) -> MapTest in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? MapTest() : instance as! MapTest
              
              result.mapMapOfString = Decoders.decodeOptional(clazz: Dictionary.self, source: sourceDictionary["map_map_of_string"] as AnyObject?)
              if let mapOfEnumString = sourceDictionary["map_of_enum_string"] as? [String:String] { //TODO: handle enum map scenario
2:1206,1223c
3:762,779c
          Decoders.addDecoder(clazz: MapTest.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MapTest> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? MapTest() : instance as! MapTest
                  switch Decoders.decodeOptional(clazz: [String:[String:String]].self, source: sourceDictionary["map_map_of_string"] as AnyObject?) {
                  
                  case let .success(value): result.mapMapOfString = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: MapTest.MapOfEnumString.self, source: sourceDictionary["map_of_enum_string"] as AnyObject?) {
                  /*
                  case let .success(value): result.mapOfEnumString = value
                  case let .failure(error): return .failure(error)
                  */ default: break //TODO: handle enum map scenario
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "MapTest", actual: "\(source)"))
====1
1:486,487c
              
              return result
2:1224a
3:780a
====1
1:491,494c
          // Decoder for [MixedPropertiesAndAdditionalPropertiesClass]
          Decoders.addDecoder(clazz: [MixedPropertiesAndAdditionalPropertiesClass].self) { (source: AnyObject, instance: AnyObject?) -> [MixedPropertiesAndAdditionalPropertiesClass] in
              return Decoders.decode(clazz: [MixedPropertiesAndAdditionalPropertiesClass].self, source: source)
          }
2:1227a
3:783a
====1
1:496,503c
          Decoders.addDecoder(clazz: MixedPropertiesAndAdditionalPropertiesClass.self) { (source: AnyObject, instance: AnyObject?) -> MixedPropertiesAndAdditionalPropertiesClass in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? MixedPropertiesAndAdditionalPropertiesClass() : instance as! MixedPropertiesAndAdditionalPropertiesClass
              
              result.uuid = Decoders.decodeOptional(clazz: UUID.self, source: sourceDictionary["uuid"] as AnyObject?)
              result.dateTime = Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["dateTime"] as AnyObject?)
              result.map = Decoders.decodeOptional(clazz: Dictionary.self, source: sourceDictionary["map"] as AnyObject?)
              return result
2:1229,1253c
3:785,809c
          Decoders.addDecoder(clazz: MixedPropertiesAndAdditionalPropertiesClass.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<MixedPropertiesAndAdditionalPropertiesClass> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? MixedPropertiesAndAdditionalPropertiesClass() : instance as! MixedPropertiesAndAdditionalPropertiesClass
                  switch Decoders.decodeOptional(clazz: UUID.self, source: sourceDictionary["uuid"] as AnyObject?) {
                  
                  case let .success(value): result.uuid = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["dateTime"] as AnyObject?) {
                  
                  case let .success(value): result.dateTime = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: [String:Animal].self, source: sourceDictionary["map"] as AnyObject?) {
                  
                  case let .success(value): result.map = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "MixedPropertiesAndAdditionalPropertiesClass", actual: "\(source)"))
              }
====1
1:507,510c
          // Decoder for [Model200Response]
          Decoders.addDecoder(clazz: [Model200Response].self) { (source: AnyObject, instance: AnyObject?) -> [Model200Response] in
              return Decoders.decode(clazz: [Model200Response].self, source: source)
          }
2:1256a
3:812a
====1
1:512,518c
          Decoders.addDecoder(clazz: Model200Response.self) { (source: AnyObject, instance: AnyObject?) -> Model200Response in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Model200Response() : instance as! Model200Response
              
              result.name = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["name"] as AnyObject?)
              result._class = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["class"] as AnyObject?)
              return result
2:1258,1276c
3:814,832c
          Decoders.addDecoder(clazz: Model200Response.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Model200Response> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? Model200Response() : instance as! Model200Response
                  switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["name"] as AnyObject?) {
                  
                  case let .success(value): result.name = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["class"] as AnyObject?) {
                  
                  case let .success(value): result._class = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "Model200Response", actual: "\(source)"))
              }
====1
1:522,525c
          // Decoder for [Name]
          Decoders.addDecoder(clazz: [Name].self) { (source: AnyObject, instance: AnyObject?) -> [Name] in
              return Decoders.decode(clazz: [Name].self, source: source)
          }
2:1279a
3:835a
====1
1:527,535c
          Decoders.addDecoder(clazz: Name.self) { (source: AnyObject, instance: AnyObject?) -> Name in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Name() : instance as! Name
              
              result.name = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["name"] as AnyObject?)
              result.snakeCase = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["snake_case"] as AnyObject?)
              result.property = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["property"] as AnyObject?)
              result._123Number = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["123Number"] as AnyObject?)
              return result
2:1281,1311c
3:837,867c
          Decoders.addDecoder(clazz: Name.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Name> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? Name() : instance as! Name
                  switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["name"] as AnyObject?) {
                  
                  case let .success(value): result.name = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["snake_case"] as AnyObject?) {
                  
                  case let .success(value): result.snakeCase = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["property"] as AnyObject?) {
                  
                  case let .success(value): result.property = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["123Number"] as AnyObject?) {
                  
                  case let .success(value): result._123Number = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "Name", actual: "\(source)"))
              }
====1
1:539,542c
          // Decoder for [NumberOnly]
          Decoders.addDecoder(clazz: [NumberOnly].self) { (source: AnyObject, instance: AnyObject?) -> [NumberOnly] in
              return Decoders.decode(clazz: [NumberOnly].self, source: source)
          }
2:1314a
3:870a
====1
1:544,549c
          Decoders.addDecoder(clazz: NumberOnly.self) { (source: AnyObject, instance: AnyObject?) -> NumberOnly in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? NumberOnly() : instance as! NumberOnly
              
              result.justNumber = Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["JustNumber"] as AnyObject?)
              return result
2:1316,1328c
3:872,884c
          Decoders.addDecoder(clazz: NumberOnly.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<NumberOnly> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? NumberOnly() : instance as! NumberOnly
                  switch Decoders.decodeOptional(clazz: Double.self, source: sourceDictionary["JustNumber"] as AnyObject?) {
                  
                  case let .success(value): result.justNumber = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "NumberOnly", actual: "\(source)"))
              }
====1
1:553,556c
          // Decoder for [Order]
          Decoders.addDecoder(clazz: [Order].self) { (source: AnyObject, instance: AnyObject?) -> [Order] in
              return Decoders.decode(clazz: [Order].self, source: source)
          }
2:1331a
3:887a
====1
1:558,571c
          Decoders.addDecoder(clazz: Order.self) { (source: AnyObject, instance: AnyObject?) -> Order in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Order() : instance as! Order
              
              result.id = Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?)
              result.petId = Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["petId"] as AnyObject?)
              result.quantity = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["quantity"] as AnyObject?)
              result.shipDate = Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["shipDate"] as AnyObject?)
              if let status = sourceDictionary["status"] as? String { 
                  result.status = Order.Status(rawValue: (status))
              }
              
              result.complete = Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["complete"] as AnyObject?)
              return result
2:1333,1375c
3:889,931c
          Decoders.addDecoder(clazz: Order.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Order> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? Order() : instance as! Order
                  switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                  
                  case let .success(value): result.id = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["petId"] as AnyObject?) {
                  
                  case let .success(value): result.petId = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["quantity"] as AnyObject?) {
                  
                  case let .success(value): result.quantity = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Date.self, source: sourceDictionary["shipDate"] as AnyObject?) {
                  
                  case let .success(value): result.shipDate = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Order.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                  
                  case let .success(value): result.status = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Bool.self, source: sourceDictionary["complete"] as AnyObject?) {
                  
                  case let .success(value): result.complete = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "Order", actual: "\(source)"))
              }
====1
1:575,578c
          // Decoder for [OuterBoolean]
          Decoders.addDecoder(clazz: [OuterBoolean].self) { (source: AnyObject) -> [OuterBoolean] in
              return Decoders.decode(clazz: [OuterBoolean].self, source: source)
          }
2:1378a
3:934a
====1
1:580c
          Decoders.addDecoder(clazz: OuterBoolean.self) { (source: AnyObject) -> OuterBoolean in
2:1380c
3:936c
          Decoders.addDecoder(clazz: OuterBoolean.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OuterBoolean> in
====1
1:582c
                  return source
2:1382,1384c
3:938,940c
                  return .success(source)
              } else {
                  return .failure(.typeMismatch(expected: "Typealias OuterBoolean", actual: "\(source)"))
====1
1:584c
              fatalError("Source \(source) is not convertible to typealias OuterBoolean: Maybe swagger file is insufficient")
2:1385a
3:941a
====1
1:588,591c
          // Decoder for [OuterComposite]
          Decoders.addDecoder(clazz: [OuterComposite].self) { (source: AnyObject) -> [OuterComposite] in
              return Decoders.decode(clazz: [OuterComposite].self, source: source)
          }
2:1388a
3:944a
====1
1:593,600c
          Decoders.addDecoder(clazz: OuterComposite.self) { (source: AnyObject) -> OuterComposite in
              let sourceDictionary = source as! [AnyHashable: Any]
  
              let instance = OuterComposite()
              instance.myNumber = Decoders.decodeOptional(clazz: OuterNumber.self, source: sourceDictionary["my_number"] as AnyObject?)
              instance.myString = Decoders.decodeOptional(clazz: OuterString.self, source: sourceDictionary["my_string"] as AnyObject?)
              instance.myBoolean = Decoders.decodeOptional(clazz: OuterBoolean.self, source: sourceDictionary["my_boolean"] as AnyObject?)
              return instance
2:1390,1414c
3:946,970c
          Decoders.addDecoder(clazz: OuterComposite.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OuterComposite> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? OuterComposite() : instance as! OuterComposite
                  switch Decoders.decodeOptional(clazz: OuterNumber.self, source: sourceDictionary["my_number"] as AnyObject?) {
                  
                  case let .success(value): result.myNumber = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: OuterString.self, source: sourceDictionary["my_string"] as AnyObject?) {
                  
                  case let .success(value): result.myString = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: OuterBoolean.self, source: sourceDictionary["my_boolean"] as AnyObject?) {
                  
                  case let .success(value): result.myBoolean = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "OuterComposite", actual: "\(source)"))
              }
====1
1:604,607c
          // Decoder for [OuterEnum]
          Decoders.addDecoder(clazz: [OuterEnum].self) { (source: AnyObject, instance: AnyObject?) -> [OuterEnum] in
              return Decoders.decode(clazz: [OuterEnum].self, source: source)
          }
2:1417a
3:973a
====1
1:609,615c
          Decoders.addDecoder(clazz: OuterEnum.self) { (source: AnyObject, instance: AnyObject?) -> OuterEnum in
              if let source = source as? String {
                  if let result = OuterEnum(rawValue: source) {
                      return result
                  }
              }
              fatalError("Source \(source) is not convertible to enum type OuterEnum: Maybe swagger file is insufficient")
2:1419,1421c
3:975,977c
          Decoders.addDecoder(clazz: OuterEnum.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OuterEnum> in
              //TODO: I don't think we need this anymore
              return Decoders.decode(clazz: OuterEnum.self, source: source, instance: instance)
====1
1:619,622c
          // Decoder for [OuterNumber]
          Decoders.addDecoder(clazz: [OuterNumber].self) { (source: AnyObject) -> [OuterNumber] in
              return Decoders.decode(clazz: [OuterNumber].self, source: source)
          }
2:1424a
3:980a
====
1:624c
          Decoders.addDecoder(clazz: OuterNumber.self) { (source: AnyObject) -> OuterNumber in
2:1426,1432c
  <<<<<<< HEAD
          Decoders.addDecoder(clazz: OuterNumber.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OuterNumber> in
  ||||||| 4479382ced
          Decoders.addDecoder(clazz: OuterNumber.self) { (source: AnyObject) -> OuterNumber in
  =======
          Decoders.addDecoder(clazz: OuterNumber.self) { (source: AnyObject, instance: AnyObject?) -> OuterNumber in
  >>>>>>> TEMP_RIGHT_BRANCH
3:982c
          Decoders.addDecoder(clazz: OuterNumber.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OuterNumber> in
====1
1:626c
                  return source
2:1434,1436c
3:984,986c
                  return .success(source)
              } else {
                  return .failure(.typeMismatch(expected: "Typealias OuterNumber", actual: "\(source)"))
====1
1:628c
              fatalError("Source \(source) is not convertible to typealias OuterNumber: Maybe swagger file is insufficient")
2:1437a
3:987a
====
1:632,635c
          // Decoder for [OuterString]
          Decoders.addDecoder(clazz: [OuterString].self) { (source: AnyObject) -> [OuterString] in
              return Decoders.decode(clazz: [OuterString].self, source: source)
          }
2:1441,1452c
  <<<<<<< HEAD
  ||||||| 4479382ced
          // Decoder for [OuterString]
          Decoders.addDecoder(clazz: [OuterString].self) { (source: AnyObject) -> [OuterString] in
              return Decoders.decode(clazz: [OuterString].self, source: source)
          }
  =======
          // Decoder for [OuterString]
          Decoders.addDecoder(clazz: [OuterString].self) { (source: AnyObject, instance: AnyObject?) -> [OuterString] in
              return Decoders.decode(clazz: [OuterString].self, source: source)
          }
  >>>>>>> TEMP_RIGHT_BRANCH
3:990a
====
1:637c
          Decoders.addDecoder(clazz: OuterString.self) { (source: AnyObject) -> OuterString in
2:1454,1460c
  <<<<<<< HEAD
          Decoders.addDecoder(clazz: OuterString.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OuterString> in
  ||||||| 4479382ced
          Decoders.addDecoder(clazz: OuterString.self) { (source: AnyObject) -> OuterString in
  =======
          Decoders.addDecoder(clazz: OuterString.self) { (source: AnyObject, instance: AnyObject?) -> OuterString in
  >>>>>>> TEMP_RIGHT_BRANCH
3:992c
          Decoders.addDecoder(clazz: OuterString.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<OuterString> in
====1
1:639c
                  return source
2:1462,1464c
3:994,996c
                  return .success(source)
              } else {
                  return .failure(.typeMismatch(expected: "Typealias OuterString", actual: "\(source)"))
====1
1:641c
              fatalError("Source \(source) is not convertible to typealias OuterString: Maybe swagger file is insufficient")
2:1465a
3:997a
====1
1:645,648c
          // Decoder for [Pet]
          Decoders.addDecoder(clazz: [Pet].self) { (source: AnyObject, instance: AnyObject?) -> [Pet] in
              return Decoders.decode(clazz: [Pet].self, source: source)
          }
2:1468a
3:1000a
====1
1:650,663c
          Decoders.addDecoder(clazz: Pet.self) { (source: AnyObject, instance: AnyObject?) -> Pet in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Pet() : instance as! Pet
              
              result.id = Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?)
              result.category = Decoders.decodeOptional(clazz: Category.self, source: sourceDictionary["category"] as AnyObject?)
              result.name = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?)
              result.photoUrls = Decoders.decodeOptional(clazz: Array.self, source: sourceDictionary["photoUrls"] as AnyObject?)
              result.tags = Decoders.decodeOptional(clazz: Array.self, source: sourceDictionary["tags"] as AnyObject?)
              if let status = sourceDictionary["status"] as? String { 
                  result.status = Pet.Status(rawValue: (status))
              }
              
              return result
2:1470,1512c
3:1002,1044c
          Decoders.addDecoder(clazz: Pet.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Pet> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? Pet() : instance as! Pet
                  switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                  
                  case let .success(value): result.id = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Category.self, source: sourceDictionary["category"] as AnyObject?) {
                  
                  case let .success(value): result.category = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                  
                  case let .success(value): result.name = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: [String].self, source: sourceDictionary["photoUrls"] as AnyObject?) {
                  
                  case let .success(value): result.photoUrls = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: [Tag].self, source: sourceDictionary["tags"] as AnyObject?) {
                  
                  case let .success(value): result.tags = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Pet.Status.self, source: sourceDictionary["status"] as AnyObject?) {
                  
                  case let .success(value): result.status = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "Pet", actual: "\(source)"))
              }
====1
1:667,670c
          // Decoder for [ReadOnlyFirst]
          Decoders.addDecoder(clazz: [ReadOnlyFirst].self) { (source: AnyObject, instance: AnyObject?) -> [ReadOnlyFirst] in
              return Decoders.decode(clazz: [ReadOnlyFirst].self, source: source)
          }
2:1515a
3:1047a
====1
1:672,678c
          Decoders.addDecoder(clazz: ReadOnlyFirst.self) { (source: AnyObject, instance: AnyObject?) -> ReadOnlyFirst in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? ReadOnlyFirst() : instance as! ReadOnlyFirst
              
              result.bar = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bar"] as AnyObject?)
              result.baz = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["baz"] as AnyObject?)
              return result
2:1517,1535c
3:1049,1067c
          Decoders.addDecoder(clazz: ReadOnlyFirst.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<ReadOnlyFirst> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? ReadOnlyFirst() : instance as! ReadOnlyFirst
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["bar"] as AnyObject?) {
                  
                  case let .success(value): result.bar = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["baz"] as AnyObject?) {
                  
                  case let .success(value): result.baz = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "ReadOnlyFirst", actual: "\(source)"))
              }
====1
1:682,685c
          // Decoder for [Return]
          Decoders.addDecoder(clazz: [Return].self) { (source: AnyObject, instance: AnyObject?) -> [Return] in
              return Decoders.decode(clazz: [Return].self, source: source)
          }
2:1538a
3:1070a
====1
1:687,692c
          Decoders.addDecoder(clazz: Return.self) { (source: AnyObject, instance: AnyObject?) -> Return in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Return() : instance as! Return
              
              result._return = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["return"] as AnyObject?)
              return result
2:1540,1552c
3:1072,1084c
          Decoders.addDecoder(clazz: Return.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Return> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? Return() : instance as! Return
                  switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["return"] as AnyObject?) {
                  
                  case let .success(value): result._return = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "Return", actual: "\(source)"))
              }
====1
1:696,699c
          // Decoder for [SpecialModelName]
          Decoders.addDecoder(clazz: [SpecialModelName].self) { (source: AnyObject, instance: AnyObject?) -> [SpecialModelName] in
              return Decoders.decode(clazz: [SpecialModelName].self, source: source)
          }
2:1555a
3:1087a
====1
1:701,706c
          Decoders.addDecoder(clazz: SpecialModelName.self) { (source: AnyObject, instance: AnyObject?) -> SpecialModelName in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? SpecialModelName() : instance as! SpecialModelName
              
              result.specialPropertyName = Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["$special[property.name]"] as AnyObject?)
              return result
2:1557,1569c
3:1089,1101c
          Decoders.addDecoder(clazz: SpecialModelName.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<SpecialModelName> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? SpecialModelName() : instance as! SpecialModelName
                  switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["$special[property.name]"] as AnyObject?) {
                  
                  case let .success(value): result.specialPropertyName = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "SpecialModelName", actual: "\(source)"))
              }
====1
1:710,713c
          // Decoder for [Tag]
          Decoders.addDecoder(clazz: [Tag].self) { (source: AnyObject, instance: AnyObject?) -> [Tag] in
              return Decoders.decode(clazz: [Tag].self, source: source)
          }
2:1572a
3:1104a
====1
1:715,721c
          Decoders.addDecoder(clazz: Tag.self) { (source: AnyObject, instance: AnyObject?) -> Tag in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? Tag() : instance as! Tag
              
              result.id = Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?)
              result.name = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?)
              return result
2:1574,1592c
3:1106,1124c
          Decoders.addDecoder(clazz: Tag.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<Tag> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? Tag() : instance as! Tag
                  switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                  
                  case let .success(value): result.id = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["name"] as AnyObject?) {
                  
                  case let .success(value): result.name = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "Tag", actual: "\(source)"))
              }
====1
1:725,728c
          // Decoder for [User]
          Decoders.addDecoder(clazz: [User].self) { (source: AnyObject, instance: AnyObject?) -> [User] in
              return Decoders.decode(clazz: [User].self, source: source)
          }
2:1595a
3:1127a
====1
1:730,742c
          Decoders.addDecoder(clazz: User.self) { (source: AnyObject, instance: AnyObject?) -> User in
              let sourceDictionary = source as! [AnyHashable: Any]
              let result = instance == nil ? User() : instance as! User
              
              result.id = Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?)
              result.username = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?)
              result.firstName = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["firstName"] as AnyObject?)
              result.lastName = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lastName"] as AnyObject?)
              result.email = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?)
              result.password = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?)
              result.phone = Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["phone"] as AnyObject?)
              result.userStatus = Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["userStatus"] as AnyObject?)
              return result
2:1597,1651c
3:1129,1183c
          Decoders.addDecoder(clazz: User.self) { (source: AnyObject, instance: AnyObject?) -> Decoded<User> in
              if let sourceDictionary = source as? [AnyHashable: Any] {
                  let result = instance == nil ? User() : instance as! User
                  switch Decoders.decodeOptional(clazz: Int64.self, source: sourceDictionary["id"] as AnyObject?) {
                  
                  case let .success(value): result.id = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["username"] as AnyObject?) {
                  
                  case let .success(value): result.username = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["firstName"] as AnyObject?) {
                  
                  case let .success(value): result.firstName = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["lastName"] as AnyObject?) {
                  
                  case let .success(value): result.lastName = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["email"] as AnyObject?) {
                  
                  case let .success(value): result.email = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["password"] as AnyObject?) {
                  
                  case let .success(value): result.password = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: String.self, source: sourceDictionary["phone"] as AnyObject?) {
                  
                  case let .success(value): result.phone = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  switch Decoders.decodeOptional(clazz: Int32.self, source: sourceDictionary["userStatus"] as AnyObject?) {
                  
                  case let .success(value): result.userStatus = value
                  case let .failure(error): return .failure(error)
                  
                  }
                  return .success(result)
              } else {
                  return .failure(.typeMismatch(expected: "User", actual: "\(source)"))
              }
====1
1:749c
  }
\ No newline at end of file
2:1658c
3:1190c
  }
