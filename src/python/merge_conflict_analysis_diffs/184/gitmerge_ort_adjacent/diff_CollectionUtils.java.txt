====1
1:30a
2:31c
3:31c
  import java.util.Objects;
====3
1:75c
2:76c
          public CardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {
3:76c
          CardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {
====3
1:142c
2:143c
          public SetOperationCardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {
3:143c
          SetOperationCardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {
====3
1:187c
2:188c
       * <code>CollectionUtils</code> should not normally be instantiated.
3:188c
       * {@code CollectionUtils} should not normally be instantiated.
====3
1:205c
2:206c
       * Returns an immutable empty collection if the argument is <code>null</code>,
3:206c
       * Returns an immutable empty collection if the argument is {@code null},
====3
1:209,210c
2:210,211c
       * @param collection the collection, possibly <code>null</code>
       * @return an empty collection if the argument is <code>null</code>
3:210,211c
       * @param collection the collection, possibly {@code null}
       * @return an empty collection if the argument is {@code null}
====1
1:232a
2:234,235c
3:234,235c
          Objects.requireNonNull(a, "The first collection must not be null.");
          Objects.requireNonNull(b, "The second collection must not be null.");
====1
1:257a
2:261,262c
3:261,262c
          Objects.requireNonNull(a, "The first collection must not be null.");
          Objects.requireNonNull(b, "The second collection must not be null.");
====1
1:287a
2:293,294c
3:293,294c
          Objects.requireNonNull(a, "The first collection must not be null.");
          Objects.requireNonNull(b, "The second collection must not be null.");
====1
1:340a
2:348,350c
3:348,350c
          Objects.requireNonNull(a, "The first collection must not be null.");
          Objects.requireNonNull(b, "The second collection must not be null.");
          Objects.requireNonNull(p, "The predicate must not be null.");
====3
1:357c
2:367c
       * Returns <code>true</code> iff all elements of {@code coll2} are also contained
3:367c
       * Returns {@code true} iff all elements of {@code coll2} are also contained
====3
1:361c
2:371c
       * In other words, this method returns <code>true</code> iff the
3:371c
       * In other words, this method returns {@code true} iff the
====3
1:376c
2:386c
       * @return <code>true</code> iff the intersection of the collections has the same cardinality
3:386c
       * @return {@code true} iff the intersection of the collections has the same cardinality
====1
1:380a
2:391,392c
3:391,392c
          Objects.requireNonNull(coll1, "The first collection must not be null.");
          Objects.requireNonNull(coll2, "The second collection must not be null.");
====3
1:409c
2:421c
       * Returns <code>true</code> iff at least one element is in both collections.
3:421c
       * Returns {@code true} iff at least one element is in both collections.
====3
1:411c
2:423c
       * In other words, this method returns <code>true</code> iff the
3:423c
       * In other words, this method returns {@code true} iff the
====3
1:415c
2:427c
       * @param <T> the type of object to lookup in <code>coll1</code>.
3:427c
       * @param <T> the type of object to lookup in {@code coll1}.
====3
1:418c
2:430c
       * @return <code>true</code> iff the intersection of the collections is non-empty
3:430c
       * @return {@code true} iff the intersection of the collections is non-empty
====1
1:422a
2:435,436c
3:435,436c
          Objects.requireNonNull(coll1, "The collection must not be null.");
          Objects.requireNonNull(coll2, "The elements must not be null.");
====3
1:440c
2:454c
       * Returns <code>true</code> iff at least one element is in both collections.
3:454c
       * Returns {@code true} iff at least one element is in both collections.
====3
1:442c
2:456c
       * In other words, this method returns <code>true</code> iff the
3:456c
       * In other words, this method returns {@code true} iff the
====3
1:448c
2:462c
       * @return <code>true</code> iff the intersection of the collections is non-empty
3:462c
       * @return {@code true} iff the intersection of the collections is non-empty
====1
1:452a
2:467,468c
3:467,468c
          Objects.requireNonNull(coll1, "The first collection must not be null.");
          Objects.requireNonNull(coll2, "The second collection must not be null.");
====1
1:482a
2:499c
3:499c
          Objects.requireNonNull(coll, "The collection must not be null.");
====3
1:503c
2:520c
       * @return <code>true</code> iff <i>a</i> is a sub-collection of <i>b</i>
3:520c
       * @return {@code true} iff <i>a</i> is a sub-collection of <i>b</i>
====1
1:507a
2:525,526c
3:525,526c
          Objects.requireNonNull(a, "The first collection must not be null.");
          Objects.requireNonNull(b, "The second collection must not be null.");
====3
1:528c
2:547c
       *    <li><code>a.size()</code> and <code>b.size()</code> represent the
3:547c
       *    <li>{@code a.size()} and {@code b.size()} represent the
====3
1:530c
2:549c
       *    <li><code>a.size() &lt; Integer.MAXVALUE</code></li>
3:549c
       *    <li>{@code a.size() &lt; Integer.MAXVALUE}</li>
====3
1:535c
2:554c
       * @return <code>true</code> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>
3:554c
       * @return {@code true} iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>
====1
1:539a
2:559,560c
3:559,560c
          Objects.requireNonNull(a, "The first collection must not be null.");
          Objects.requireNonNull(b, "The second collection must not be null.");
====3
1:554c
2:575c
       * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.
3:575c
       * @return {@code true} iff the collections contain the same elements with the same cardinalities.
====
1:557c
          if(a.size() != b.size()) {
2:578,580c
          Objects.requireNonNull(a, "The first collection must not be null.");
          Objects.requireNonNull(b, "The second collection must not be null.");
          if(a.size() != b.size()) {
3:578,580c
          Objects.requireNonNull(a, "The first collection must not be null.");
          Objects.requireNonNull(b, "The second collection must not be null.");
          if (a.size() != b.size()) {
====3
1:561c
2:584c
          if(helper.cardinalityA.size() != helper.cardinalityB.size()) {
3:584c
          if (helper.cardinalityA.size() != helper.cardinalityB.size()) {
====3
1:564,565c
2:587,588c
          for( final Object obj : helper.cardinalityA.keySet()) {
              if(helper.freqA(obj) != helper.freqB(obj)) {
3:587,588c
          for (final Object obj : helper.cardinalityA.keySet()) {
              if (helper.freqA(obj) != helper.freqB(obj)) {
====3
1:591c
2:614c
       * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.
3:614c
       * @return {@code true} iff the collections contain the same elements with the same cardinalities.
====
1:598,602c
          if (equator == null) {
              throw new NullPointerException("Equator must not be null.");
          }
  
          if(a.size() != b.size()) {
2:621,624c
          Objects.requireNonNull(a, "The first collection must not be null.");
          Objects.requireNonNull(b, "The second collection must not be null.");
          Objects.requireNonNull(equator, "The equator must not be null.");
          if(a.size() != b.size()) {
3:621,625c
          Objects.requireNonNull(a, "The first collection must not be null.");
          Objects.requireNonNull(b, "The second collection must not be null.");
          Objects.requireNonNull(equator, "equator");
  
          if (a.size() != b.size()) {
====3
1:626c
2:648c
          public EquatorWrapper(final Equator<? super O> equator, final O object) {
3:649c
          EquatorWrapper(final Equator<? super O> equator, final O object) {
====3
1:655c
2:677c
       * @param coll the {@link Iterable} to search
3:678c
       * @param collection the {@link Iterable} to search
====
1:663,667c
      public static <O> int cardinality(final O obj, final Iterable<? super O> coll) {
          if (coll == null) {
              throw new NullPointerException("coll must not be null.");
          }
          return IterableUtils.frequency(coll, obj);
2:685,687c
      public static <O> int cardinality(final O obj, final Iterable<? super O> coll) {
          Objects.requireNonNull(coll, "The collection must not be null.");
          return IterableUtils.frequency(coll, obj);
3:686,687c
      public static <O> int cardinality(final O obj, final Iterable<? super O> collection) {
          return IterableUtils.frequency(Objects.requireNonNull(collection, "collection"), obj);
====3
1:799c
2:819c
       * This is equivalent to <code>filter(collection, PredicateUtils.notPredicate(predicate))</code>
3:819c
       * This is equivalent to {@code filter(collection, PredicateUtils.notPredicate(predicate))}
====3
1:856c
2:876c
       * A <code>null</code> collection or predicate matches no elements.
3:876c
       * A {@code null} collection or predicate matches no elements.
====3
1:874c
2:894c
       * A <code>null</code> collection or predicate returns false.
3:894c
       * A {@code null} collection or predicate returns false.
====3
1:893c
2:913c
       * A <code>null</code> predicate returns false.
3:913c
       * A {@code null} predicate returns false.
====3
1:896c
2:916c
       * A <code>null</code> or empty collection returns true.
3:916c
       * A {@code null} or empty collection returns true.
====3
1:916c
2:936c
       * A <code>null</code> predicate matches no elements.
3:936c
       * A {@code null} predicate matches no elements.
====1
1:923c
       * @throws NullPointerException if the input collection is null
2:942a
3:942a
====1
1:927,928c
          final Collection<O> answer = inputCollection instanceof Collection<?> ?
                  new ArrayList<>(((Collection<?>) inputCollection).size()) : new ArrayList<>();
2:946,950c
3:946,950c
          int size = 0;
          if (null != inputCollection) {
              size = inputCollection instanceof Collection<?> ? ((Collection<?>) inputCollection).size() : 0;
          }
          final Collection<O> answer = size == 0 ? new ArrayList<>() : new ArrayList<>(size);
====3
1:965,966c
2:987,988c
       * Elements matching the predicate are added to the <code>outputCollection</code>,
       * all other elements are added to the <code>rejectedCollection</code>.
3:987,988c
       * Elements matching the predicate are added to the {@code outputCollection},
       * all other elements are added to the {@code rejectedCollection}.
====3
1:969,970c
2:991,992c
       * If the input predicate is <code>null</code>, no elements are added to
       * <code>outputCollection</code> or <code>rejectedCollection</code>.
3:991,992c
       * If the input predicate is {@code null}, no elements are added to
       * {@code outputCollection} or {@code rejectedCollection}.
====3
1:1010c
2:1032c
       * If the input predicate is <code>null</code>, the result is an empty
3:1032c
       * If the input predicate is {@code null}, the result is an empty
====1
1:1018c
       * @throws NullPointerException if the input collection is null
2:1039a
3:1039a
====1
1:1022,1023c
          final Collection<O> answer = inputCollection instanceof Collection<?> ?
                  new ArrayList<>(((Collection<?>) inputCollection).size()) : new ArrayList<>();
2:1043,1047c
3:1043,1047c
          int size = 0;
          if (null != inputCollection) {
              size = inputCollection instanceof Collection<?> ? ((Collection<?>) inputCollection).size() : 0;
          }
          final Collection<O> answer = size == 0 ? new ArrayList<>() : new ArrayList<>(size);
====3
1:1031,1032c
2:1055,1056c
       * If the input predicate is <code>null</code>, no elements are added to
       * <code>outputCollection</code>.
3:1055,1056c
       * If the input predicate is {@code null}, no elements are added to
       * {@code outputCollection}.
====1
1:1072,1073c
          final Collection<O> answer = inputCollection instanceof Collection<?> ?
                  new ArrayList<>(((Collection<?>) inputCollection).size()) : new ArrayList<>();
2:1096,1100c
3:1096,1100c
          int size = 0;
          if (null != inputCollection) {
              size = inputCollection instanceof Collection<?> ? ((Collection<?>) inputCollection).size() : 0;
          }
          final Collection<O> answer = size == 0 ? new ArrayList<>() : new ArrayList<>(size);
====
1:1165,1167c
          if (collection == null) {
              throw new NullPointerException("The collection must not be null");
          }
2:1192c
          Objects.requireNonNull(collection, "The collection must not be null.");
3:1192c
          Objects.requireNonNull(collection, "collection");
====1
1:1182a
2:1208,1209c
3:1208,1209c
          Objects.requireNonNull(collection, "The collection must not be null.");
          Objects.requireNonNull(iterable, "The iterable of elements to add must not be null.");
====1
1:1198a
2:1226,1227c
3:1226,1227c
          Objects.requireNonNull(collection, "The collection must not be null.");
          Objects.requireNonNull(iterator, "The iterator of elements to add must not be null.");
====1
1:1215a
2:1245,1246c
3:1245,1246c
          Objects.requireNonNull(collection, "The collection must not be null.");
          Objects.requireNonNull(enumeration, "The enumeration of elements to add must not be null.");
====1
1:1232a
2:1264,1265c
3:1264,1265c
          Objects.requireNonNull(collection, "The collection must not be null.");
          Objects.requireNonNull(elements, "The array of elements to add must not be null.");
====3
1:1241,1242c
2:1274,1275c
       * Returns the <code>index</code>-th value in {@link Iterator}, throwing
       * <code>IndexOutOfBoundsException</code> if there is no such element.
3:1274,1275c
       * Returns the {@code index}-th value in {@link Iterator}, throwing
       * {@code IndexOutOfBoundsException} if there is no such element.
====3
1:1244,1245c
2:1277,1278c
       * The Iterator is advanced to <code>index</code> (or to the end, if
       * <code>index</code> exceeds the number of entries) as a side effect of this method.
3:1277,1278c
       * The Iterator is advanced to {@code index} (or to the end, if
       * {@code index} exceeds the number of entries) as a side effect of this method.
====1
1:1257a
2:1291c
3:1291c
          Objects.requireNonNull(iterator, "The iterator must not be null.");
====3
1:1273,1274c
2:1307,1308c
       * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing
       * <code>IndexOutOfBoundsException</code> if there is no such element.
3:1307,1308c
       * Returns the {@code index}-th value in the {@code iterable}'s {@link Iterator}, throwing
       * {@code IndexOutOfBoundsException} if there is no such element.
====1
1:1287a
2:1322c
3:1322c
          Objects.requireNonNull(iterable, "The iterable must not be null.");
====3
1:1292,1294c
2:1327,1329c
       * Returns the <code>index</code>-th value in <code>object</code>, throwing
       * <code>IndexOutOfBoundsException</code> if there is no such element or
       * <code>IllegalArgumentException</code> if <code>object</code> is not an
3:1327,1329c
       * Returns the {@code index}-th value in {@code object}, throwing
       * {@code IndexOutOfBoundsException} if there is no such element or
       * {@code IllegalArgumentException} if {@code object} is not an
====3
1:1300,1301c
2:1335,1336c
       * <li> Map -- the value returned is the <code>Map.Entry</code> in position
       *      <code>index</code> in the map's <code>entrySet</code> iterator,
3:1335,1336c
       * <li> Map -- the value returned is the {@code Map.Entry} in position
       *      {@code index} in the map's {@code entrySet} iterator,
====3
1:1304,1305c
2:1339,1340c
       * <li> Array -- the <code>index</code>-th array entry is returned,
       *      if there is such an entry; otherwise an <code>IndexOutOfBoundsException</code>
3:1339,1340c
       * <li> Array -- the {@code index}-th array entry is returned,
       *      if there is such an entry; otherwise an {@code IndexOutOfBoundsException}
====3
1:1307c
2:1342c
       * <li> Collection -- the value returned is the <code>index</code>-th object
3:1342c
       * <li> Collection -- the value returned is the {@code index}-th object
====3
1:1310c
2:1345c
       *      <code>index</code>-th object in the Iterator/Enumeration, if there
3:1345c
       *      {@code index}-th object in the Iterator/Enumeration, if there
====3
1:1312c
2:1347c
       *      <code>index</code> (or to the end, if <code>index</code> exceeds the
3:1347c
       *      {@code index} (or to the end, if {@code index} exceeds the
====3
1:1327c
2:1362c
          if (object instanceof Map<?,?>) {
3:1362c
          if (object instanceof Map<?, ?>) {
====3
1:1354,1355c
2:1389,1390c
       * Returns the <code>index</code>-th <code>Map.Entry</code> in the <code>map</code>'s <code>entrySet</code>,
       * throwing <code>IndexOutOfBoundsException</code> if there is no such element.
3:1389,1390c
       * Returns the {@code index}-th {@code Map.Entry} in the {@code map}'s {@code entrySet},
       * throwing {@code IndexOutOfBoundsException} if there is no such element.
====1
1:1358c
       * @param <V>  the key type in the {@link Map}
2:1393c
3:1393c
       * @param <V>  the value type in the {@link Map}
====1
1:1364c
      public static <K,V> Map.Entry<K, V> get(final Map<K,V> map, final int index) {
2:1399,1400c
3:1399,1400c
      public static <K, V> Map.Entry<K, V> get(final Map<K, V> map, final int index) {
          Objects.requireNonNull(map, "The map must not be null.");
====3
1:1392c
2:1428c
          if (object instanceof Map<?,?>) {
3:1428c
          if (object instanceof Map<?, ?>) {
====1
1:1499a
2:1536c
3:1536c
          Objects.requireNonNull(array, "The array must not be null.");
====3
1:1526c
2:1563c
       * @param coll  the collection to check
3:1563c
       * @param collection  the collection to check
====
1:1530,1535c
      public static boolean isFull(final Collection<? extends Object> coll) {
          if (coll == null) {
              throw new NullPointerException("The collection must not be null");
          }
          if (coll instanceof BoundedCollection) {
              return ((BoundedCollection<?>) coll).isFull();
2:1567,1570c
      public static boolean isFull(final Collection<? extends Object> coll) {
          Objects.requireNonNull(coll, "The collection must not be null");
          if (coll instanceof BoundedCollection) {
              return ((BoundedCollection<?>) coll).isFull();
3:1567,1570c
      public static boolean isFull(final Collection<? extends Object> collection) {
          Objects.requireNonNull(collection, "collection");
          if (collection instanceof BoundedCollection) {
              return ((BoundedCollection<?>) collection).isFull();
====3
1:1539c
2:1574c
                      UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);
3:1574c
                      UnmodifiableBoundedCollection.unmodifiableBoundedCollection(collection);
====3
1:1559c
2:1594c
       * @param coll  the collection to check
3:1594c
       * @param collection  the collection to check
====
1:1563,1568c
      public static int maxSize(final Collection<? extends Object> coll) {
          if (coll == null) {
              throw new NullPointerException("The collection must not be null");
          }
          if (coll instanceof BoundedCollection) {
              return ((BoundedCollection<?>) coll).maxSize();
2:1598,1601c
      public static int maxSize(final Collection<? extends Object> coll) {
          Objects.requireNonNull(coll, "The collection must not be null");
          if (coll instanceof BoundedCollection) {
              return ((BoundedCollection<?>) coll).maxSize();
3:1598,1601c
      public static int maxSize(final Collection<? extends Object> collection) {
          Objects.requireNonNull(collection, "collection");
          if (collection instanceof BoundedCollection) {
              return ((BoundedCollection<?>) collection).maxSize();
====3
1:1572c
2:1605c
                      UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);
3:1605c
                      UnmodifiableBoundedCollection.unmodifiableBoundedCollection(collection);
====3
1:1649,1651c
2:1682,1684c
       * @param a  the first collection, must not be null
       * @param b  the second collection, must not be null
       * @param c  the comparator to use for the merge.
3:1682,1684c
       * @param iterableA  the first collection, must not be null
       * @param iterableB  the second collection, must not be null
       * @param comparator  the comparator to use for the merge.
====
1:1658,1666c
      public static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b,
                                        final Comparator<? super O> c, final boolean includeDuplicates) {
  
          if (a == null || b == null) {
              throw new NullPointerException("The collections must not be null");
          }
          if (c == null) {
              throw new NullPointerException("The comparator must not be null");
          }
2:1691,1695c
      public static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b,
                                        final Comparator<? super O> c, final boolean includeDuplicates) {
          Objects.requireNonNull(a, "The first collection must not be null.");
          Objects.requireNonNull(b, "The second collection must not be null.");
          Objects.requireNonNull(c, "The comparator must not be null.");
3:1691,1696c
      public static <O> List<O> collate(final Iterable<? extends O> iterableA, final Iterable<? extends O> iterableB,
                                        final Comparator<? super O> comparator, final boolean includeDuplicates) {
  
          Objects.requireNonNull(iterableA, "iterableA");
          Objects.requireNonNull(iterableB, "iterableB");
          Objects.requireNonNull(comparator, "comparator");
====3
1:1669,1670c
2:1698,1699c
          final int totalSize = a instanceof Collection<?> && b instanceof Collection<?> ?
                  Math.max(1, ((Collection<?>) a).size() + ((Collection<?>) b).size()) : 10;
3:1699,1700c
          final int totalSize = iterableA instanceof Collection<?> && iterableB instanceof Collection<?> ?
                  Math.max(1, ((Collection<?>) iterableA).size() + ((Collection<?>) iterableB).size()) : 10;
====3
1:1672c
2:1701c
          final Iterator<O> iterator = new CollatingIterator<>(c, a.iterator(), b.iterator());
3:1702c
          final Iterator<O> iterator = new CollatingIterator<>(comparator, iterableA.iterator(), iterableB.iterator());
====1
1:1713a
2:1743c
3:1744c
          Objects.requireNonNull(collection, "The collection must not be null.");
====3
1:1724,1727c
2:1754,1757c
       * Returns a collection containing all the elements in <code>collection</code>
       * that are also in <code>retain</code>. The cardinality of an element <code>e</code>
       * in the returned collection is the same as the cardinality of <code>e</code>
       * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which
3:1755,1758c
       * Returns a collection containing all the elements in {@code collection}
       * that are also in {@code retain}. The cardinality of an element {@code e}
       * in the returned collection is the same as the cardinality of {@code e}
       * in {@code collection} unless {@code retain} does not contain {@code e}, in which
====3
1:1729c
2:1759c
       * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.
3:1760c
       * the collection {@code c} and thus cannot call {@code c.retainAll(retain);}.
====3
1:1731,1732c
2:1761,1762c
       * This implementation iterates over <code>collection</code>, checking each element in
       * turn to see if it's contained in <code>retain</code>. If it's contained, it's added
3:1762,1763c
       * This implementation iterates over {@code collection}, checking each element in
       * turn to see if it's contained in {@code retain}. If it's contained, it's added
====3
1:1734c
2:1764c
       * <code>retain</code> that provides a fast (e.g. O(1)) implementation of
3:1765c
       * {@code retain} that provides a fast (e.g. O(1)) implementation of
====3
1:1741,1742c
2:1771,1772c
       * @return a <code>Collection</code> containing all the elements of <code>collection</code>
       * that occur at least once in <code>retain</code>.
3:1772,1773c
       * @return a {@code Collection} containing all the elements of {@code collection}
       * that occur at least once in {@code retain}.
====1
1:1746a
2:1777,1778c
3:1778,1779c
          Objects.requireNonNull(collection, "The first collection must not be null.");
          Objects.requireNonNull(retain, "The second collection must not be null.");
====3
1:1752,1755c
2:1784,1787c
       * <code>collection</code> that are also in <code>retain</code>. The
       * cardinality of an element <code>e</code> in the returned collection is
       * the same as the cardinality of <code>e</code> in <code>collection</code>
       * unless <code>retain</code> does not contain <code>e</code>, in which case
3:1785,1788c
       * {@code collection} that are also in {@code retain}. The
       * cardinality of an element {@code e} in the returned collection is
       * the same as the cardinality of {@code e} in {@code collection}
       * unless {@code retain} does not contain {@code e}, in which case
====3
1:1757,1758c
2:1789,1790c
       * modify the collection <code>c</code> and thus cannot call
       * <code>c.retainAll(retain);</code>.
3:1790,1791c
       * modify the collection {@code c} and thus cannot call
       * {@code c.retainAll(retain);}.
====3
1:1762c
2:1794c
       * in <code>collection</code> and <code>retain</code>. Hence this method is
3:1795c
       * in {@code collection} and {@code retain}. Hence this method is
====3
1:1771,1772c
2:1803,1804c
       * @return a <code>Collection</code> containing all the elements of <code>collection</code>
       * that occur at least once in <code>retain</code> according to the <code>equator</code>
3:1804,1805c
       * @return a {@code Collection} containing all the elements of {@code collection}
       * that occur at least once in {@code retain} according to the {@code equator}
====1
1:1779c
  
2:1811,1813c
3:1812,1814c
          Objects.requireNonNull(collection, "The first collection must not be null.");
          Objects.requireNonNull(retain, "The second collection must not be null.");
          Objects.requireNonNull(equator, "The equator must not be null.");
====1
1:1800,1802c
       * @param input  the collection will be operated, can't be null
       * @param startIndex  the start index (inclusive) to remove element, can't be less than 0
       * @param endIndex  the end index (exclusive) to remove, can't be less than startIndex
2:1834,1836c
3:1835,1837c
       * @param input  the collection will be operated, must not be null
       * @param startIndex  the start index (inclusive) to remove element, must not be less than 0
       * @param endIndex  the end index (exclusive) to remove, must not be less than startIndex
====1
1:1807,1809c
          if (null == input) {
              throw new IllegalArgumentException("The collection can't be null.");
          }
2:1841c
3:1842c
          Objects.requireNonNull(input, "The collection must not be null.");
====1
1:1831,1833c
          if (null == input) {
              throw new IllegalArgumentException("The collection can't be null.");
          }
2:1863c
3:1864c
          Objects.requireNonNull(input, "The collection must not be null.");
====3
1:1845,1846c
2:1875,1876c
          Collection<E> result = new ArrayList<E>(count);
          Iterator<E> iterator = input.iterator();
3:1876,1877c
          final Collection<E> result = new ArrayList<>(count);
          final Iterator<E> iterator = input.iterator();
====3
1:1861,1865c
2:1891,1895c
       * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this
       * method returns a collection containing all the elements in <code>c</code>
       * that are not in <code>remove</code>. The cardinality of an element <code>e</code>
       * in the returned collection is the same as the cardinality of <code>e</code>
       * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which
3:1892,1896c
       * Removes the elements in {@code remove} from {@code collection}. That is, this
       * method returns a collection containing all the elements in {@code c}
       * that are not in {@code remove}. The cardinality of an element {@code e}
       * in the returned collection is the same as the cardinality of {@code e}
       * in {@code collection} unless {@code remove} contains {@code e}, in which
====3
1:1867c
2:1897c
       * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.
3:1898c
       * the collection {@code c} and thus cannot call {@code collection.removeAll(remove);}.
====3
1:1869,1870c
2:1899,1900c
       * This implementation iterates over <code>collection</code>, checking each element in
       * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added
3:1900,1901c
       * This implementation iterates over {@code collection}, checking each element in
       * turn to see if it's contained in {@code remove}. If it's not contained, it's added
====3
1:1872c
2:1902c
       * <code>remove</code> that provides a fast (e.g. O(1)) implementation of
3:1903c
       * {@code remove} that provides a fast (e.g. O(1)) implementation of
====3
1:1878,1880c
2:1908,1910c
       * @param remove  the items to be removed from the returned <code>collection</code>
       * @return a <code>Collection</code> containing all the elements of <code>collection</code> except
       * any elements that also occur in <code>remove</code>.
3:1909,1911c
       * @param remove  the items to be removed from the returned {@code collection}
       * @return a {@code Collection} containing all the elements of {@code collection} except
       * any elements that also occur in {@code remove}.
====3
1:1886c
2:1916c
    }
3:1917c
      }
====3
1:1889c
2:1919c
       * Removes all elements in <code>remove</code> from <code>collection</code>.
3:1920c
       * Removes all elements in {@code remove} from {@code collection}.
====3
1:1891,1894c
2:1921,1924c
       * <code>collection</code> that are not in <code>remove</code>. The
       * cardinality of an element <code>e</code> in the returned collection is
       * the same as the cardinality of <code>e</code> in <code>collection</code>
       * unless <code>remove</code> contains <code>e</code>, in which case the
3:1922,1925c
       * {@code collection} that are not in {@code remove}. The
       * cardinality of an element {@code e} in the returned collection is
       * the same as the cardinality of {@code e} in {@code collection}
       * unless {@code remove} contains {@code e}, in which case the
====3
1:1896,1897c
2:1926,1927c
       * the collection <code>c</code> and thus cannot call
       * <code>collection.removeAll(remove)</code>.
3:1927,1928c
       * the collection {@code c} and thus cannot call
       * {@code collection.removeAll(remove)}.
====3
1:1901c
2:1931c
       * in <code>collection</code> and <code>remove</code>. Hence this method is
3:1932c
       * in {@code collection} and {@code remove}. Hence this method is
====3
1:1910,1911c
2:1940,1941c
       * @return a <code>Collection</code> containing all the elements of <code>collection</code>
       * except any element that if equal according to the <code>equator</code>
3:1941,1942c
       * @return a {@code Collection} containing all the elements of {@code collection}
       * except any element that if equal according to the {@code equator}
====1
1:1918c
  
2:1948,1950c
3:1949,1951c
          Objects.requireNonNull(collection, "The collection must not be null.");
          Objects.requireNonNull(remove, "The items to be removed must not be null.");
          Objects.requireNonNull(equator, "The equator must not be null.");
====1
1:1960a
2:1993c
3:1994c
          Objects.requireNonNull(collection, "The collection must not be null.");
====1
1:1977a
2:2011c
3:2012c
          Objects.requireNonNull(collection, "The collection must not be null.");
====1
1:1997a
2:2032,2033c
3:2033,2034c
          Objects.requireNonNull(collection, "The collection must not be null.");
          Objects.requireNonNull(predicate, "The predicate must not be null.");
====1
1:2020a
2:2057,2058c
3:2058,2059c
          Objects.requireNonNull(collection, "The collection must not be null.");
          Objects.requireNonNull(transformer, "The transformer must not be null.");
====
1:2035,2037c
          if (collection == null) {
              throw new NullPointerException("Collection must not be null.");
          }
2:2073c
          Objects.requireNonNull(collection, "The collection must not be null.");
3:2074c
          Objects.requireNonNull(collection, "collection");
