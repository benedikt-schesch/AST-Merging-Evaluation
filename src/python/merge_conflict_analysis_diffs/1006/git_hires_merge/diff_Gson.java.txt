====1
1:19,37c
  import java.io.EOFException;
  import java.io.IOException;
  import java.io.Reader;
  import java.io.StringReader;
  import java.io.StringWriter;
  import java.io.Writer;
  import java.lang.reflect.Type;
  import java.math.BigDecimal;
  import java.math.BigInteger;
  import java.text.DateFormat;
  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.HashMap;
  import java.util.List;
  import java.util.Map;
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.concurrent.atomic.AtomicLong;
  import java.util.concurrent.atomic.AtomicLongArray;
  
2:18a
3:18a
====3
1:53a
2:34a
3:35c
  import com.google.gson.internal.bind.SerializationDelegatingTypeAdapter;
====
1:60a
2:42,61c
  import java.io.EOFException;
  import java.io.IOException;
  import java.io.Reader;
  import java.io.StringReader;
  import java.io.StringWriter;
  import java.io.Writer;
  import java.lang.reflect.Type;
  import java.math.BigDecimal;
  import java.math.BigInteger;
  import java.text.DateFormat;
  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.Iterator;
  import java.util.LinkedHashMap;
  import java.util.List;
  import java.util.Map;
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.concurrent.ConcurrentMap;
  import java.util.concurrent.atomic.AtomicLong;
  import java.util.concurrent.atomic.AtomicLongArray;
3:43,63c
  import java.io.EOFException;
  import java.io.IOException;
  import java.io.Reader;
  import java.io.StringReader;
  import java.io.StringWriter;
  import java.io.Writer;
  import java.lang.reflect.Type;
  import java.math.BigDecimal;
  import java.math.BigInteger;
  import java.text.DateFormat;
  import java.util.ArrayList;
  import java.util.Collections;
  import java.util.Iterator;
  import java.util.LinkedHashMap;
  import java.util.List;
  import java.util.Map;
  import java.util.Objects;
  import java.util.concurrent.ConcurrentHashMap;
  import java.util.concurrent.ConcurrentMap;
  import java.util.concurrent.atomic.AtomicLong;
  import java.util.concurrent.atomic.AtomicLongArray;
====3
1:78c
2:79c
   * String json = gson.toJson(target); // serializes target to Json
3:81c
   * String json = gson.toJson(target); // serializes target to JSON
====3
1:82,86c
2:83,87c
   * <p>If the object that your are serializing/deserializing is a {@code ParameterizedType}
   * (i.e. contains at least one type parameter and may be an array) then you must use the
   * {@link #toJson(Object, Type)} or {@link #fromJson(String, Type)} method. Here is an
   * example for serializing and deserializing a {@code ParameterizedType}:
   *
3:85,91c
   * <p>If the type of the object that you are converting is a {@code ParameterizedType}
   * (i.e. has at least one type argument, for example {@code List<MyType>}) then for
   * deserialization you must use a {@code fromJson} method with {@link Type} or {@link TypeToken}
   * parameter to specify the parameterized type. For serialization specifying a {@code Type}
   * or {@code TypeToken} is optional, otherwise Gson will use the runtime type of the object.
   * {@link TypeToken} is a class provided by Gson which helps creating parameterized types.
   * Here is an example showing how this can be done:
====3
1:88,90c
2:89,91c
   * Type listType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();
   * List&lt;String&gt; target = new LinkedList&lt;String&gt;();
   * target.add("blah");
3:93,95c
   * TypeToken&lt;List&lt;MyType&gt;&gt; listType = new TypeToken&lt;List&lt;MyType&gt;&gt;() {};
   * List&lt;MyType&gt; target = new LinkedList&lt;MyType&gt;();
   * target.add(new MyType(1, "abc"));
====3
1:93,94c
2:94,95c
   * String json = gson.toJson(target, listType);
   * List&lt;String&gt; target2 = gson.fromJson(json, listType);
3:98,103c
   * // For serialization you normally do not have to specify the type, Gson will use
   * // the runtime type of the objects, however you can also specify it explicitly
   * String json = gson.toJson(target, listType.getType());
   *
   * // But for deserialization you have to specify the type
   * List&lt;MyType&gt; target2 = gson.fromJson(json, listType);
====3
1:97c
2:98c
   * <p>See the <a href="https://sites.google.com/site/gson/gson-user-guide">Gson User Guide</a>
3:106c
   * <p>See the <a href="https://github.com/google/gson/blob/master/UserGuide.md">Gson User Guide</a>
====3
1:100c
2:101c
   * @see com.google.gson.reflect.TypeToken
3:109,136c
   * <h2>Lenient JSON handling</h2>
   * For legacy reasons most of the {@code Gson} methods allow JSON data which does not
   * comply with the JSON specification, regardless of whether {@link GsonBuilder#setLenient()}
   * is used or not. If this behavior is not desired, the following workarounds can be used:
   *
   * <h3>Serialization</h3>
   * <ol>
   *   <li>Use {@link #getAdapter(Class)} to obtain the adapter for the type to be serialized
   *   <li>When using an existing {@code JsonWriter}, manually apply the writer settings of this
   *       {@code Gson} instance listed by {@link #newJsonWriter(Writer)}.<br>
   *       Otherwise, when not using an existing {@code JsonWriter}, use {@link #newJsonWriter(Writer)}
   *       to construct one.
   *   <li>Call {@link TypeAdapter#write(JsonWriter, Object)}
   * </ol>
   *
   * <h3>Deserialization</h3>
   * <ol>
   *   <li>Use {@link #getAdapter(Class)} to obtain the adapter for the type to be deserialized
   *   <li>When using an existing {@code JsonReader}, manually apply the reader settings of this
   *       {@code Gson} instance listed by {@link #newJsonReader(Reader)}.<br>
   *       Otherwise, when not using an existing {@code JsonReader}, use {@link #newJsonReader(Reader)}
   *       to construct one.
   *   <li>Call {@link TypeAdapter#read(JsonReader)}
   *   <li>Call {@link JsonReader#peek()} and verify that the result is {@link JsonToken#END_DOCUMENT}
   *       to make sure there is no trailing data
   * </ol>
   *
   * @see TypeToken
====3
1:120c
2:121c
    private static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);
3:155a
====1
1:130,131c
    private final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls
        = new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>();
2:131,132c
3:165,166c
    // Uses LinkedHashMap because iteration order is important, see getAdapter() implementation below
    private final ThreadLocal<LinkedHashMap<TypeToken<?>, TypeAdapter<?>>> calls = new ThreadLocal<>();
====
1:133c
    private final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();
2:134c
    private final ConcurrentMap<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();
3:168c
    private final ConcurrentMap<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<>();
====3
1:158a
2:159a
3:194c
    final List<ReflectionAccessFilter> reflectionFilters;
====3
1:185c
2:186c
     *   <li>The default field naming policy for the output Json is same as in Java. So, a Java class
3:221c
     *   <li>The default field naming policy for the output JSON is same as in Java. So, a Java class
====3
1:187c
2:188c
     *   Json. The same rules are applied for mapping incoming Json to the Java classes. You can
3:223c
     *   JSON. The same rules are applied for mapping incoming JSON to the Java classes. You can
====3
1:202c
2:203c
          Collections.<TypeAdapterFactory>emptyList(), DEFAULT_OBJECT_TO_NUMBER_STRATEGY, DEFAULT_NUMBER_TO_NUMBER_STRATEGY);
3:238,239c
          Collections.<TypeAdapterFactory>emptyList(), DEFAULT_OBJECT_TO_NUMBER_STRATEGY, DEFAULT_NUMBER_TO_NUMBER_STRATEGY,
          Collections.<ReflectionAccessFilter>emptyList());
====3
1:214c
2:215c
        ToNumberStrategy objectToNumberStrategy, ToNumberStrategy numberToNumberStrategy) {
3:251,252c
        ToNumberStrategy objectToNumberStrategy, ToNumberStrategy numberToNumberStrategy,
        List<ReflectionAccessFilter> reflectionFilters) {
====3
1:218c
2:219c
      this.constructorConstructor = new ConstructorConstructor(instanceCreators, useJdkUnsafe);
3:256c
      this.constructorConstructor = new ConstructorConstructor(instanceCreators, useJdkUnsafe, reflectionFilters);
====3
1:234a
2:235a
3:273c
      this.reflectionFilters = reflectionFilters;
====3
1:236c
2:237c
      List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();
3:275c
      List<TypeAdapterFactory> factories = new ArrayList<>();
====3
1:299c
2:300c
          constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));
3:338c
          constructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory, reflectionFilters));
====3
1:308a
2:309a
3:348c
     * @since 2.8.3
====3
1:371c
2:372c
          out.value(value);
3:411c
          out.value(doubleValue);
====3
1:395c
2:396c
          out.value(value);
3:435,438c
          // For backward compatibility don't call `JsonWriter.value(float)` because that method has
          // been newly added and not all custom JsonWriter implementations might override it yet
          Number floatNumber = value instanceof Float ? value : floatValue;
          out.value(floatNumber);
====3
1:452c
2:453c
          List<Long> list = new ArrayList<Long>();
3:495c
          List<Long> list = new ArrayList<>();
====3
1:475c
2:476c
    @SuppressWarnings("unchecked")
3:517a
====3
1:477c
2:478c
      TypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);
3:519,520c
      Objects.requireNonNull(type, "type must not be null");
      TypeAdapter<?> cached = typeTokenCache.get(type);
====3
1:479c
2:480c
        return (TypeAdapter<T>) cached;
3:522,524c
        @SuppressWarnings("unchecked")
        TypeAdapter<T> adapter = (TypeAdapter<T>) cached;
        return adapter;
====1
1:482,483c
      Map<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();
      boolean requiresThreadLocalCleanup = false;
2:483,484c
3:527,528c
      LinkedHashMap<TypeToken<?>, TypeAdapter<?>> threadCalls = calls.get();
      boolean isInitialAdapterRequest = false;
====1
1:485c
        threadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();
2:486c
3:530c
        threadCalls = new LinkedHashMap<>();
====1
1:487c
        requiresThreadLocalCleanup = true;
2:488c
3:532c
        isInitialAdapterRequest = true;
====
1:491c
      FutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);
2:492c
      TypeAdapter<T> ongoingCall = (TypeAdapter<T>) threadCalls.get(type);
3:536,537c
      @SuppressWarnings("unchecked")
      TypeAdapter<T> ongoingCall = (TypeAdapter<T>) threadCalls.get(type);
====1
1:495a
2:497,498c
3:542,543c
      int existingAdaptersCount = threadCalls.size();
      boolean foundCandidate = false;
====1
1:497c
        FutureTypeAdapter<T> call = new FutureTypeAdapter<T>();
2:500c
3:545c
        FutureTypeAdapter<T> call = new FutureTypeAdapter<>();
====
1:504c
            typeTokenCache.put(type, candidate);
2:507,519c
            // Replace future adapter with actual adapter
            threadCalls.put(type, candidate);
  
            if (isInitialAdapterRequest) {
              // Publish resolved adapters to all threads
              // Can only do this for the initial request because cyclic dependency TypeA -> TypeB -> TypeA
              // would otherwise publish adapter for TypeB which uses not yet resolved adapter for TypeA
              // See https://github.com/google/gson/issues/625
              for (Map.Entry<TypeToken<?>, TypeAdapter<?>> resolvedAdapterEntry : threadCalls.entrySet()) {
                typeTokenCache.putIfAbsent(resolvedAdapterEntry.getKey(), resolvedAdapterEntry.getValue());
              }
            }
            foundCandidate = true;
3:552,570c
            // Replace future adapter with actual adapter
            threadCalls.put(type, candidate);
  
            if (isInitialAdapterRequest) {
              // Publish resolved adapters to all threads
              // Can only do this for the initial request because cyclic dependency TypeA -> TypeB -> TypeA
              // would otherwise publish adapter for TypeB which uses not yet resolved adapter for TypeA
              // See https://github.com/google/gson/issues/625
              for (Map.Entry<TypeToken<?>, TypeAdapter<?>> resolvedAdapterEntry : threadCalls.entrySet()) {
                typeTokenCache.putIfAbsent(resolvedAdapterEntry.getKey(), resolvedAdapterEntry.getValue());
              }
  
              @SuppressWarnings("unchecked")
              TypeAdapter<T> actualAdapter = (TypeAdapter<T>) typeTokenCache.get(type);
              // Prefer the actual adapter, in case putIfAbsent call above had no effect because other
              // thread already concurrently added other adapter instance for the same type
              candidate = actualAdapter;
            }
            foundCandidate = true;
====1
1:510,512c
        threadCalls.remove(type);
  
        if (requiresThreadLocalCleanup) {
2:525c
3:576c
        if (isInitialAdapterRequest) {
====
1:514a
2:528,545c
        if (!foundCandidate) {
          Iterator<TypeAdapter<?>> adaptersIterator = threadCalls.values().iterator();
          // Skip existing non-broken adapters
          for (; existingAdaptersCount > 0; existingAdaptersCount--) {
            adaptersIterator.next();
          }
          // Remove this future adapter and all nested ones because they might
          // refer to broken adapters
          while (adaptersIterator.hasNext()) {
            TypeAdapter<?> brokenAdapter = adaptersIterator.next();
            if (brokenAdapter instanceof FutureTypeAdapter) {
              // Mark adapter as broken so user sees useful exception message in
              // case TypeAdapterFactory leaks reference to broken adapter
              ((FutureTypeAdapter<T>) brokenAdapter).markBroken();
            }
            adaptersIterator.remove();
          }
        }
3:579,596c
        if (!foundCandidate) {
          Iterator<TypeAdapter<?>> adaptersIterator = threadCalls.values().iterator();
          // Skip existing non-broken adapters
          for (; existingAdaptersCount > 0; existingAdaptersCount--) {
            adaptersIterator.next();
          }
          // Remove this future adapter and all nested ones because they might
          // refer to broken adapters
          while (adaptersIterator.hasNext()) {
            TypeAdapter<?> brokenAdapter = adaptersIterator.next();
            if (brokenAdapter instanceof FutureTypeAdapter) {
              // Mark adapter as broken so user sees useful exception message in
              // case TypeAdapterFactory leaks reference to broken adapter
              ((FutureTypeAdapter<?>) brokenAdapter).markBroken();
            }
            adaptersIterator.remove();
          }
        }
====3
1:607c
2:638c
     * of Java. Note that this method works fine if the any of the object fields are of generic type,
3:689c
     * of Java. Note that this method works fine if any of the object fields are of generic type,
====3
1:611,612c
2:642,643c
     * @param src the object for which Json representation is to be created setting for Gson
     * @return Json representation of {@code src}.
3:693,694c
     * @param src the object for which JSON representation is to be created
     * @return JSON representation of {@code src}.
====3
1:613a
2:644a
3:696,697c
     *
     * @see #toJsonTree(Object, Type)
====3
1:636a
2:667a
3:721,722c
     *
     * @see #toJsonTree(Object)
====3
1:645c
2:676c
     * This method serializes the specified object into its equivalent Json representation.
3:731c
     * This method serializes the specified object into its equivalent JSON representation.
====3
1:649c
2:680c
     * of Java. Note that this method works fine if the any of the object fields are of generic type,
3:735c
     * of Java. Note that this method works fine if any of the object fields are of generic type,
====3
1:654c
2:685c
     * @param src the object for which Json representation is to be created setting for Gson
3:740c
     * @param src the object for which JSON representation is to be created
====3
1:655a
2:686a
3:742,744c
     *
     * @see #toJson(Object, Appendable)
     * @see #toJson(Object, Type)
====3
1:666c
2:697c
     * equivalent Json representation. This method must be used if the specified object is a generic
3:755c
     * equivalent JSON representation. This method must be used if the specified object is a generic
====3
1:677c
2:708c
     * @return Json representation of {@code src}
3:766,769c
     * @return JSON representation of {@code src}
     *
     * @see #toJson(Object, Type, Appendable)
     * @see #toJson(Object)
====3
1:686c
2:717c
     * This method serializes the specified object into its equivalent Json representation.
3:778,779c
     * This method serializes the specified object into its equivalent JSON representation and
     * writes it to the writer.
====3
1:690c
2:721c
     * of Java. Note that this method works fine if the any of the object fields are of generic type,
3:783c
     * of Java. Note that this method works fine if any of the object fields are of generic type,
====3
1:694,695c
2:725,726c
     * @param src the object for which Json representation is to be created setting for Gson
     * @param writer Writer to which the Json representation needs to be written
3:787,788c
     * @param src the object for which JSON representation is to be created
     * @param writer Writer to which the JSON representation needs to be written
====3
1:697a
2:728a
3:791,793c
     *
     * @see #toJson(Object)
     * @see #toJson(Object, Type, Appendable)
====3
1:709,710c
2:740,741c
     * equivalent Json representation. This method must be used if the specified object is a generic
     * type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.
3:805,807c
     * equivalent JSON representation and writes it to the writer.
     * This method must be used if the specified object is a generic type. For non-generic objects,
     * use {@link #toJson(Object, Appendable)} instead.
====3
1:719c
2:750c
     * @param writer Writer to which the Json representation of src needs to be written.
3:816c
     * @param writer Writer to which the JSON representation of src needs to be written.
====3
1:721a
2:752a
3:819,821c
     *
     * @see #toJson(Object, Type)
     * @see #toJson(Object, Appendable)
====3
1:734a
2:765a
3:835,843c
     *
     * <p>The JSON data is written in {@linkplain JsonWriter#setLenient(boolean) lenient mode},
     * regardless of the lenient mode setting of the provided writer. The lenient mode setting
     * of the writer is restored once this method returns.
     *
     * <p>The 'HTML-safe' and 'serialize {@code null}' settings of this {@code Gson} instance
     * (configured by the {@link GsonBuilder}) are applied, and the original settings of the
     * writer are restored once this method returns.
     *
====3
1:737c
2:768c
    @SuppressWarnings("unchecked")
3:845a
====3
1:739c
2:770c
      TypeAdapter<?> adapter = getAdapter(TypeToken.get(typeOfSrc));
3:847,848c
      @SuppressWarnings("unchecked")
      TypeAdapter<Object> adapter = (TypeAdapter<Object>) getAdapter(TypeToken.get(typeOfSrc));
====3
1:747c
2:778c
        ((TypeAdapter<Object>) adapter).write(writer, src);
3:856c
        adapter.write(writer, src);
====3
1:778c
2:809c
     * @param writer Writer to which the Json representation needs to be written
3:887c
     * @param writer Writer to which the JSON representation needs to be written
====3
1:832a
2:863a
3:942,950c
     *
     * <p>The JSON data is written in {@linkplain JsonWriter#setLenient(boolean) lenient mode},
     * regardless of the lenient mode setting of the provided writer. The lenient mode setting
     * of the writer is restored once this method returns.
     *
     * <p>The 'HTML-safe' and 'serialize {@code null}' settings of this {@code Gson} instance
     * (configured by the {@link GsonBuilder}) are applied, and the original settings of the
     * writer are restored once this method returns.
     *
====3
1:858c
2:889c
     * This method deserializes the specified Json into an object of the specified class. It is not
3:976c
     * This method deserializes the specified JSON into an object of the specified class. It is not
====3
1:864c
2:895c
     * {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of
3:982c
     * {@link #fromJson(String, TypeToken)}. If you have the JSON in a {@link Reader} instead of
====3
1:866a
2:897a
3:985,987c
     * <p>An exception is thrown if the JSON string has multiple top-level JSON elements, or if there
     * is trailing data. Use {@link #fromJson(JsonReader, Type)} if this behavior is not desired.
     *
====3
1:873a
2:904a
3:995,997c
     *
     * @see #fromJson(Reader, Class)
     * @see #fromJson(String, TypeToken)
====3
1:876c
2:907c
      Object object = fromJson(json, (Type) classOfT);
3:1000c
      T object = fromJson(json, TypeToken.get(classOfT));
====3
1:881c
2:912c
     * This method deserializes the specified Json into an object of the specified type. This method
3:1005c
     * This method deserializes the specified JSON into an object of the specified type. This method
====3
1:883c
2:914c
     * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of
3:1007c
     * {@link #fromJson(String, Class)} instead. If you have the JSON in a {@link Reader} instead of
====3
1:886,889c
2:917,920c
     * @param <T> the type of the desired object
     * @param json the string from which the object is to be deserialized
     * @param typeOfT The specific genericized type of src. You can obtain this type by using the
     * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
3:1010,1047c
     * <p>Since {@code Type} is not parameterized by T, this method is not type-safe and
     * should be used carefully. If you are creating the {@code Type} from a {@link TypeToken},
     * prefer using {@link #fromJson(String, TypeToken)} instead since its return type is based
     * on the {@code TypeToken} and is therefore more type-safe.
     *
     * <p>An exception is thrown if the JSON string has multiple top-level JSON elements,
     * or if there is trailing data. Use {@link #fromJson(JsonReader, Type)} if this behavior is
     * not desired.
     *
     * @param <T> the type of the desired object
     * @param json the string from which the object is to be deserialized
     * @param typeOfT The specific genericized type of src
     * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}
     * or if {@code json} is empty.
     * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
     *
     * @see #fromJson(Reader, Type)
     * @see #fromJson(String, Class)
     * @see #fromJson(String, TypeToken)
     */
    @SuppressWarnings("unchecked")
    public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
      return (T) fromJson(json, TypeToken.get(typeOfT));
    }
  
    /**
     * This method deserializes the specified JSON into an object of the specified type. This method
     * is useful if the specified object is a generic type. For non-generic objects, use
     * {@link #fromJson(String, Class)} instead. If you have the JSON in a {@link Reader} instead of
     * a String, use {@link #fromJson(Reader, TypeToken)} instead.
     *
     * <p>An exception is thrown if the JSON string has multiple top-level JSON elements, or if there
     * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.
     *
     * @param <T> the type of the desired object
     * @param json the string from which the object is to be deserialized
     * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of
     * {@code TypeToken} with the specific generic type arguments. For example, to get the type for
====3
1:892c
2:923c
     * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
3:1050c
     * new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}
====3
1:896,897c
2:927,928c
     * @throws JsonParseException if json is not a valid representation for an object of type typeOfT
     * @throws JsonSyntaxException if json is not a valid representation for an object of type
3:1054,1058c
     * @throws JsonSyntaxException if json is not a valid representation for an object of the type typeOfT
     *
     * @see #fromJson(Reader, TypeToken)
     * @see #fromJson(String, Class)
     * @since 2.10
====3
1:899,900c
2:930,931c
    @SuppressWarnings("unchecked")
    public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {
3:1060c
    public <T> T fromJson(String json, TypeToken<T> typeOfT) throws JsonSyntaxException {
====3
1:905,906c
2:936,937c
      T target = (T) fromJson(reader, typeOfT);
      return target;
3:1065c
      return fromJson(reader, typeOfT);
====3
1:910c
2:941c
     * This method deserializes the Json read from the specified reader into an object of the
3:1069c
     * This method deserializes the JSON read from the specified reader into an object of the
====3
1:914c
2:945c
     * this method works fine if the any of the fields of the specified object are generics, just the
3:1073c
     * this method works fine if any of the fields of the specified object are generics, just the
====3
1:916c
2:947c
     * invoke {@link #fromJson(Reader, Type)}. If you have the Json in a String form instead of a
3:1075c
     * invoke {@link #fromJson(Reader, TypeToken)}. If you have the JSON in a String form instead of a
====3
1:918a
2:949a
3:1078,1080c
     * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there
     * is trailing data. Use {@link #fromJson(JsonReader, Type)} if this behavior is not desired.
     *
====3
1:920c
2:951c
     * @param json the reader producing the Json from which the object is to be deserialized.
3:1082c
     * @param json the reader producing the JSON from which the object is to be deserialized.
====3
1:922c
2:953c
     * @return an object of type T from the string. Returns {@code null} if {@code json} is at EOF.
3:1084c
     * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.
====3
1:924c
2:955c
     * @throws JsonSyntaxException if json is not a valid representation for an object of type
3:1086c
     * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
====3
1:925a
2:956a
3:1088,1090c
     *
     * @see #fromJson(String, Class)
     * @see #fromJson(Reader, TypeToken)
====3
1:928,930c
2:959,961c
      JsonReader jsonReader = newJsonReader(json);
      Object object = fromJson(jsonReader, classOfT);
      assertFullConsumption(object, jsonReader);
3:1093c
      T object = fromJson(json, TypeToken.get(classOfT));
====3
1:935c
2:966c
     * This method deserializes the Json read from the specified reader into an object of the
3:1098c
     * This method deserializes the JSON read from the specified reader into an object of the
====3
1:937c
2:968c
     * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a
3:1100c
     * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a
====3
1:939a
2:970a
3:1103,1110c
     * <p>Since {@code Type} is not parameterized by T, this method is not type-safe and
     * should be used carefully. If you are creating the {@code Type} from a {@link TypeToken},
     * prefer using {@link #fromJson(Reader, TypeToken)} instead since its return type is based
     * on the {@code TypeToken} and is therefore more type-safe.
     *
     * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there
     * is trailing data. Use {@link #fromJson(JsonReader, Type)} if this behavior is not desired.
     *
====3
1:941,948c
2:972,979c
     * @param json the reader producing Json from which the object is to be deserialized
     * @param typeOfT The specific genericized type of src. You can obtain this type by using the
     * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
     * {@code Collection<Foo>}, you should use:
     * <pre>
     * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
     * </pre>
     * @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.
3:1112,1114c
     * @param json the reader producing JSON from which the object is to be deserialized
     * @param typeOfT The specific genericized type of src
     * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.
====3
1:950c
2:981c
     * @throws JsonSyntaxException if json is not a valid representation for an object of type
3:1116c
     * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
====3
1:951a
2:982a
3:1118,1121c
     *
     * @see #fromJson(String, Type)
     * @see #fromJson(Reader, Class)
     * @see #fromJson(Reader, TypeToken)
====3
1:954a
2:985a
3:1125,1153c
      return (T) fromJson(json, TypeToken.get(typeOfT));
    }
  
    /**
     * This method deserializes the JSON read from the specified reader into an object of the
     * specified type. This method is useful if the specified object is a generic type. For
     * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a
     * String form instead of a {@link Reader}, use {@link #fromJson(String, TypeToken)} instead.
     *
     * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there
     * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.
     *
     * @param <T> the type of the desired object
     * @param json the reader producing JSON from which the object is to be deserialized
     * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of
     * {@code TypeToken} with the specific generic type arguments. For example, to get the type for
     * {@code Collection<Foo>}, you should use:
     * <pre>
     * new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}
     * </pre>
     * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.
     * @throws JsonIOException if there was a problem reading from the Reader
     * @throws JsonSyntaxException if json is not a valid representation for an object of type of typeOfT
     *
     * @see #fromJson(String, TypeToken)
     * @see #fromJson(Reader, Class)
     * @since 2.10
     */
    public <T> T fromJson(Reader json, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {
====3
1:956c
2:987c
      T object = (T) fromJson(jsonReader, typeOfT);
3:1155c
      T object = fromJson(jsonReader, typeOfT);
====3
1:964c
2:995c
          throw new JsonIOException("JSON document was not fully consumed.");
3:1163c
          throw new JsonSyntaxException("JSON document was not fully consumed.");
====3
1:972a
2:1003a
3:1172,1174c
    // fromJson(JsonReader, Class) is unfortunately missing and cannot be added now without breaking
    // source compatibility in certain cases, see https://github.com/google/gson/pull/1700#discussion_r973764414
  
====3
1:974c
2:1005c
     * Reads the next JSON value from {@code reader} and convert it to an object
3:1176c
     * Reads the next JSON value from {@code reader} and converts it to an object
====3
1:976c
2:1007c
     * Since Type is not parameterized by T, this method is type unsafe and should be used carefully
3:1177a
====3
1:978,979c
2:1009,1010c
     * @throws JsonIOException if there was a problem writing to the Reader
     * @throws JsonSyntaxException if json is not a valid representation for an object of type
3:1179,1200c
     * <p>Since {@code Type} is not parameterized by T, this method is not type-safe and
     * should be used carefully. If you are creating the {@code Type} from a {@link TypeToken},
     * prefer using {@link #fromJson(JsonReader, TypeToken)} instead since its return type is based
     * on the {@code TypeToken} and is therefore more type-safe. If the provided type is a
     * {@code Class} the {@code TypeToken} can be created with {@link TypeToken#get(Class)}.
     *
     * <p>Unlike the other {@code fromJson} methods, no exception is thrown if the JSON data has
     * multiple top-level JSON elements, or if there is trailing data.
     *
     * <p>The JSON data is parsed in {@linkplain JsonReader#setLenient(boolean) lenient mode},
     * regardless of the lenient mode setting of the provided reader. The lenient mode setting
     * of the reader is restored once this method returns.
     *
     * @param <T> the type of the desired object
     * @param reader the reader whose next JSON value should be deserialized
     * @param typeOfT The specific genericized type of src
     * @return an object of type T from the JsonReader. Returns {@code null} if {@code reader} is at EOF.
     * @throws JsonIOException if there was a problem reading from the JsonReader
     * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
     *
     * @see #fromJson(Reader, Type)
     * @see #fromJson(JsonReader, TypeToken)
====3
1:982a
2:1013a
3:1204,1237c
      return (T) fromJson(reader, TypeToken.get(typeOfT));
    }
  
    /**
     * Reads the next JSON value from {@code reader} and converts it to an object
     * of type {@code typeOfT}. Returns {@code null}, if the {@code reader} is at EOF.
     * This method is useful if the specified object is a generic type. For non-generic objects,
     * {@link #fromJson(JsonReader, Type)} can be called, or {@link TypeToken#get(Class)} can
     * be used to create the type token.
     *
     * <p>Unlike the other {@code fromJson} methods, no exception is thrown if the JSON data has
     * multiple top-level JSON elements, or if there is trailing data.
     *
     * <p>The JSON data is parsed in {@linkplain JsonReader#setLenient(boolean) lenient mode},
     * regardless of the lenient mode setting of the provided reader. The lenient mode setting
     * of the reader is restored once this method returns.
     *
     * @param <T> the type of the desired object
     * @param reader the reader whose next JSON value should be deserialized
     * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of
     * {@code TypeToken} with the specific generic type arguments. For example, to get the type for
     * {@code Collection<Foo>}, you should use:
     * <pre>
     * new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}
     * </pre>
     * @return an object of type T from the JsonReader. Returns {@code null} if {@code reader} is at EOF.
     * @throws JsonIOException if there was a problem reading from the JsonReader
     * @throws JsonSyntaxException if json is not a valid representation for an object of the type typeOfT
     *
     * @see #fromJson(Reader, TypeToken)
     * @see #fromJson(JsonReader, Type)
     * @since 2.10
     */
    public <T> T fromJson(JsonReader reader, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {
====3
1:989,990c
2:1020,1021c
        TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);
        TypeAdapter<T> typeAdapter = getAdapter(typeToken);
3:1244c
        TypeAdapter<T> typeAdapter = getAdapter(typeOfT);
====3
1:1017c
2:1048c
     * This method deserializes the Json read from the specified parse tree into an object of the
3:1271c
     * This method deserializes the JSON read from the specified parse tree into an object of the
====3
1:1021c
2:1052c
     * this method works fine if the any of the fields of the specified object are generics, just the
3:1275c
     * this method works fine if any of the fields of the specified object are generics, just the
====3
1:1023c
2:1054c
     * invoke {@link #fromJson(JsonElement, Type)}.
3:1277,1278c
     * invoke {@link #fromJson(JsonElement, TypeToken)}.
     *
====3
1:1028c
2:1059c
     * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}
3:1283c
     * @return an object of type T from the JSON. Returns {@code null} if {@code json} is {@code null}
====3
1:1030c
2:1061c
     * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
3:1285c
     * @throws JsonSyntaxException if json is not a valid representation for an object of type classOfT
====3
1:1031a
2:1062a
3:1287,1289c
     *
     * @see #fromJson(Reader, Class)
     * @see #fromJson(JsonElement, TypeToken)
====3
1:1034c
2:1065c
      Object object = fromJson(json, (Type) classOfT);
3:1292c
      T object = fromJson(json, TypeToken.get(classOfT));
====3
1:1039c
2:1070c
     * This method deserializes the Json read from the specified parse tree into an object of the
3:1297c
     * This method deserializes the JSON read from the specified parse tree into an object of the
====3
1:1042a
2:1073a
3:1301,1305c
     * <p>Since {@code Type} is not parameterized by T, this method is not type-safe and
     * should be used carefully. If you are creating the {@code Type} from a {@link TypeToken},
     * prefer using {@link #fromJson(JsonElement, TypeToken)} instead since its return type is based
     * on the {@code TypeToken} and is therefore more type-safe.
     *
====3
1:1046,1052c
2:1077,1083c
     * @param typeOfT The specific genericized type of src. You can obtain this type by using the
     * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for
     * {@code Collection<Foo>}, you should use:
     * <pre>
     * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();
     * </pre>
     * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}
3:1309,1310c
     * @param typeOfT The specific genericized type of src
     * @return an object of type T from the JSON. Returns {@code null} if {@code json} is {@code null}
====3
1:1055a
2:1086a
3:1314,1317c
     *
     * @see #fromJson(Reader, Type)
     * @see #fromJson(JsonElement, Class)
     * @see #fromJson(JsonElement, TypeToken)
====3
1:1058a
2:1089a
3:1321,1346c
      return (T) fromJson(json, TypeToken.get(typeOfT));
    }
  
    /**
     * This method deserializes the JSON read from the specified parse tree into an object of the
     * specified type. This method is useful if the specified object is a generic type. For
     * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.
     *
     * @param <T> the type of the desired object
     * @param json the root of the parse tree of {@link JsonElement}s from which the object is to
     * be deserialized
     * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of
     * {@code TypeToken} with the specific generic type arguments. For example, to get the type for
     * {@code Collection<Foo>}, you should use:
     * <pre>
     * new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}
     * </pre>
     * @return an object of type T from the JSON. Returns {@code null} if {@code json} is {@code null}
     * or if {@code json} is empty.
     * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT
     *
     * @see #fromJson(Reader, TypeToken)
     * @see #fromJson(JsonElement, Class)
     * @since 2.10
     */
    public <T> T fromJson(JsonElement json, TypeToken<T> typeOfT) throws JsonSyntaxException {
====3
1:1062c
2:1093c
      return (T) fromJson(new JsonTreeReader(json), typeOfT);
3:1350c
      return fromJson(new JsonTreeReader(json), typeOfT);
====
1:1065,1066c
    static class FutureTypeAdapter<T> extends TypeAdapter<T> {
      private TypeAdapter<T> delegate;
2:1096,1098c
    static class FutureTypeAdapter<T> extends TypeAdapter<T> {
      private TypeAdapter<T> delegate = null;
      private boolean isBroken = false;
3:1353,1355c
    static class FutureTypeAdapter<T> extends SerializationDelegatingTypeAdapter<T> {
      private TypeAdapter<T> delegate = null;
      private boolean isBroken = false;
====
1:1075c
      @Override public T read(JsonReader in) throws IOException {
2:1107,1115c
      public void markBroken() {
        isBroken = true;
      }
  
      private TypeAdapter<T> getResolvedDelegate() {
        TypeAdapter<T> delegate = this.delegate;
        if (isBroken) {
          throw new IllegalStateException("Broken adapter has been leaked by TypeAdapterFactory");
        }
3:1364,1372c
      public void markBroken() {
        isBroken = true;
      }
  
      private TypeAdapter<T> delegate() {
        TypeAdapter<T> delegate = this.delegate;
        if (isBroken) {
          throw new IllegalStateException("Broken adapter has been leaked by TypeAdapterFactory");
        }
====1
1:1077c
          throw new IllegalStateException();
2:1117,1120c
3:1374,1377c
          // Can occur when adapter is leaked to other thread or when adapter is used for (de-)serialization
          // directly within the TypeAdapterFactory which requested it
          throw new IllegalStateException("Adapter for type with cyclic dependency has been used"
              + " before dependency has been resolved");
====
1:1079c
        return delegate.read(in);
2:1122,1126c
        return delegate;
      }
  
      @Override public T read(JsonReader in) throws IOException {
        return getResolvedDelegate().read(in);
3:1379,1387c
        return delegate;
      }
  
      @Override public TypeAdapter<T> getSerializationDelegate() {
        return delegate();
      }
  
      @Override public T read(JsonReader in) throws IOException {
        return delegate().read(in);
====
1:1083,1086c
        if (delegate == null) {
          throw new IllegalStateException();
        }
        delegate.write(out, value);
2:1130c
        getResolvedDelegate().write(out, value);
3:1391c
        delegate().write(out, value);
