====1
1:1025,1026c
          // no edge_based parameter -> use node-based (because its faster)
          assertMoscowNodeBased(tmpHopper, "none", true);
2:1025,1026c
3:1025,1026c
          // no edge_based parameter -> use edge-based (because its there)
          assertMoscowEdgeBased(tmpHopper, "none", true);
====
1:1053a
2:1054,1109c
      @Test
      public void testNodeBasedCHOnlyButTurnCostForNonCH() {
          // before edge-based CH was added a common case was to use edge-based without CH and CH for node-based
          GraphHopper tmpHopper = new GraphHopperOSM().
                  setOSMFile(DIR + "/moscow.osm.gz").
                  setStoreOnFlush(true).
                  setCHEnabled(true).
                  setGraphHopperLocation(tmpGraphFile).
                  setEncodingManager(EncodingManager.create("car|turn_costs=true"));
          tmpHopper.getCHFactoryDecorator()
                  .setEdgeBasedCHMode(CHAlgoFactoryDecorator.EdgeBasedCHMode.OFF)
                  .setDisablingAllowed(true);
          tmpHopper.importOrLoad();
  
          // without CH -> use edge-based unless disabled explicitly
          assertMoscowEdgeBased(tmpHopper, "none", false);
          assertMoscowEdgeBased(tmpHopper, "true", false);
          assertMoscowNodeBased(tmpHopper, "false", false);
  
          // with CH -> use node-based unless edge_based is enabled explicitly (which should give an error)
          assertMoscowNodeBased(tmpHopper, "none", true);
          assertMoscowNodeBased(tmpHopper, "false", true);
          GHResponse rsp = runMoscow(tmpHopper, "true", true);
          assertEquals(1, rsp.getErrors().size());
          assertTrue(rsp.getErrors().toString().contains("Found a node-based CH preparation"));
          assertTrue(rsp.getErrors().toString().contains("but requested edge-based CH"));
      }
  
      @Test
      public void testEdgeBasedByDefaultIfOnlyEdgeBased() {
          // when there is only one edge-based CH profile, there is no need to specify edge_based=true explicitly,
          // see #1637
          GraphHopper tmpHopper = new GraphHopperOSM().
                  setOSMFile(DIR + "/moscow.osm.gz").
                  setStoreOnFlush(true).
                  setCHEnabled(true).
                  setGraphHopperLocation(tmpGraphFile).
                  setEncodingManager(EncodingManager.create("car|turn_costs=true"));
          tmpHopper.getCHFactoryDecorator().setDisablingAllowed(true);
          tmpHopper.getCHFactoryDecorator().setEdgeBasedCHMode(CHAlgoFactoryDecorator.EdgeBasedCHMode.EDGE_OR_NODE);
          tmpHopper.importOrLoad();
  
          // even when we omit the edge_based parameter we get edge-based CH, unless we disable it explicitly
          assertMoscowEdgeBased(tmpHopper, "none", true);
          assertMoscowEdgeBased(tmpHopper, "true", true);
          GHResponse rsp = runMoscow(tmpHopper, "false", true);
          assertTrue(rsp.hasErrors());
  <<<<<<< HEAD
          assertTrue(rsp.getErrors().toString().contains("Found 1 edge-based CH preparation"));
  ||||||| 34b0d48a78
  =======
          assertTrue(rsp.getErrors().toString().contains("Found an edge-based CH preparation"));
  >>>>>>> TEMP_RIGHT_BRANCH
          assertTrue(rsp.getErrors().toString().contains("but requested node-based CH"));
      }
  
3:1054,1104c
      @Test
      public void testNodeBasedCHOnlyButTurnCostForNonCH() {
          // before edge-based CH was added a common case was to use edge-based without CH and CH for node-based
          GraphHopper tmpHopper = new GraphHopperOSM().
                  setOSMFile(DIR + "/moscow.osm.gz").
                  setStoreOnFlush(true).
                  setCHEnabled(true).
                  setGraphHopperLocation(tmpGraphFile).
                  setEncodingManager(EncodingManager.create("car|turn_costs=true"));
          tmpHopper.getCHFactoryDecorator()
                  .setEdgeBasedCHMode(CHAlgoFactoryDecorator.EdgeBasedCHMode.OFF)
                  .setDisablingAllowed(true);
          tmpHopper.importOrLoad();
  
          // without CH -> use edge-based unless disabled explicitly
          assertMoscowEdgeBased(tmpHopper, "none", false);
          assertMoscowEdgeBased(tmpHopper, "true", false);
          assertMoscowNodeBased(tmpHopper, "false", false);
  
          // with CH -> use node-based unless edge_based is enabled explicitly (which should give an error)
          assertMoscowNodeBased(tmpHopper, "none", true);
          assertMoscowNodeBased(tmpHopper, "false", true);
          GHResponse rsp = runMoscow(tmpHopper, "true", true);
          assertEquals(1, rsp.getErrors().size());
          assertTrue(rsp.getErrors().toString().contains("Found a node-based CH preparation"));
          assertTrue(rsp.getErrors().toString().contains("but requested edge-based CH"));
      }
  
      @Test
      public void testEdgeBasedByDefaultIfOnlyEdgeBased() {
          // when there is only one edge-based CH profile, there is no need to specify edge_based=true explicitly,
          // see #1637
          GraphHopper tmpHopper = new GraphHopperOSM().
                  setOSMFile(DIR + "/moscow.osm.gz").
                  setStoreOnFlush(true).
                  setCHEnabled(true).
                  setGraphHopperLocation(tmpGraphFile).
                  setEncodingManager(EncodingManager.create("car|turn_costs=true"));
          tmpHopper.getCHFactoryDecorator().setDisablingAllowed(true);
          tmpHopper.getCHFactoryDecorator().setEdgeBasedCHMode(CHAlgoFactoryDecorator.EdgeBasedCHMode.EDGE_OR_NODE);
          tmpHopper.importOrLoad();
  
          // even when we omit the edge_based parameter we get edge-based CH, unless we disable it explicitly
          assertMoscowEdgeBased(tmpHopper, "none", true);
          assertMoscowEdgeBased(tmpHopper, "true", true);
          GHResponse rsp = runMoscow(tmpHopper, "false", true);
          assertTrue(rsp.hasErrors());
          assertTrue(rsp.getErrors().toString().contains("Found 1 edge-based CH preparation"));
          assertTrue(rsp.getErrors().toString().contains("but requested node-based CH"));
      }
  
====1
1:1055c
          return assertMoscow(tmpHopper, edgeBasedParam, false, ch);
2:1111,1113c
3:1106,1108c
          GHResponse rsp = runMoscow(tmpHopper, edgeBasedParam, ch);
          assertEquals(400, rsp.getBest().getDistance(), 1);
          return rsp;
====1
1:1059c
          return assertMoscow(tmpHopper, edgeBasedParam, true, ch);
2:1117,1119c
3:1112,1114c
          GHResponse rsp = runMoscow(tmpHopper, edgeBasedParam, ch);
          assertEquals(1044, rsp.getBest().getDistance(), 1);
          return rsp;
====1
1:1062c
      private GHResponse assertMoscow(GraphHopper tmpHopper, String edgeBasedParam, boolean withTurnCosts, boolean ch) {
2:1122c
3:1117c
      private GHResponse runMoscow(GraphHopper tmpHopper, String edgeBasedParam, boolean ch) {
====1
1:1070,1072c
          GHResponse rsp = tmpHopper.route(req);
          assertEquals(withTurnCosts ? 1044 : 400, rsp.getBest().getDistance(), 1);
          return rsp;
2:1130c
3:1125c
          return tmpHopper.route(req);
====1
1:1086a
2:1145,1161c
3:1140,1156c
      @Test
      public void testEncoderWithTurnCostSupport_stillAllows_nodeBasedRouting() {
          // see #1698
          GraphHopper tmpHopper = new GraphHopperOSM().
                  setOSMFile(DIR + "/moscow.osm.gz").
                  setGraphHopperLocation(tmpGraphFile).
                  setCHEnabled(false).
                  setEncodingManager(EncodingManager.create("foot,car|turn_costs=true"));
          tmpHopper.importOrLoad();
          GHPoint p = new GHPoint(55.813357, 37.5958585);
          GHPoint q = new GHPoint(55.811042, 37.594689);
          GHRequest req = new GHRequest(p, q);
          req.setVehicle("foot");
          GHResponse rsp = tmpHopper.route(req);
          assertEquals("there should not be an error, but was: " + rsp.getErrors(), 0, rsp.getErrors().size());
      }
  
