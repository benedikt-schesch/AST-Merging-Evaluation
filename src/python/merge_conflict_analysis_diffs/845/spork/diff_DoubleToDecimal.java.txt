2,3c2
<  * Copyright (c) 2021, 2022, Oracle and/or its affiliates. All rights reserved.
<  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
---
>  * Copyright 2018-2020 Raffaello Giulietti
5,9c4,9
<  * This code is free software; you can redistribute it and/or modify it
<  * under the terms of the GNU General Public License version 2 only, as
<  * published by the Free Software Foundation.  Oracle designates this
<  * particular file as subject to the "Classpath" exception as provided
<  * by Oracle in the LICENSE file that accompanied this code.
---
>  * Permission is hereby granted, free of charge, to any person obtaining a copy
>  * of this software and associated documentation files (the "Software"), to deal
>  * in the Software without restriction, including without limitation the rights
>  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
>  * copies of the Software, and to permit persons to whom the Software is
>  * furnished to do so, subject to the following conditions:
11,15c11,12
<  * This code is distributed in the hope that it will be useful, but WITHOUT
<  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
<  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<  * version 2 for more details (a copy is included in the LICENSE file that
<  * accompanied this code).
---
>  * The above copyright notice and this permission notice shall be included in
>  * all copies or substantial portions of the Software.
17,23c14,20
<  * You should have received a copy of the GNU General Public License version
<  * 2 along with this work; if not, write to the Free Software Foundation,
<  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
<  *
<  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
<  * or visit www.oracle.com if you need additional information or have any
<  * questions.
---
>  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
>  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
>  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
>  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
>  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
>  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
>  * THE SOFTWARE.
30,32d26
< import static java.lang.Double.doubleToRawLongBits;
< import static java.lang.Long.numberOfLeadingZeros;
< 
40a35,37
> import static java.lang.Double.doubleToRawLongBits;
> import static java.lang.Long.numberOfLeadingZeros;
> 
42a40,41
>  *
>  * @author Raffaello Giulietti
46,57c45,56
<      * For full details about this code see the following references:
<      *
<      * [1] Giulietti, "The Schubfach way to render doubles",
<      *     https://drive.google.com/file/d/1gp5xv4CAa78SVgCeWfGqqI4FfYYYuNFb
<      *
<      * [2] IEEE Computer Society, "IEEE Standard for Floating-Point Arithmetic"
<      *
<      * [3] Bouvier & Zimmermann, "Division-Free Binary-to-Decimal Conversion"
<      *
<      * Divisions are avoided altogether for the benefit of those architectures
<      * that do not provide specific machine instructions or where they are slow.
<      * This is discussed in section 10 of [1].
---
>     For full details about this code see the following references:
> 
>     [1] Giulietti, "The Schubfach way to render doubles",
>         https://drive.google.com/open?id=1luHhyQF9zKlM8yJ1nebU0OgVYhfC6CBN
> 
>     [2] IEEE Computer Society, "IEEE Standard for Floating-Point Arithmetic"
> 
>     [3] Bouvier & Zimmermann, "Division-Free Binary-to-Decimal Conversion"
> 
>     Divisions are avoided altogether for the benefit of those architectures
>     that do not provide specific machine instructions or where they are slow.
>     This is discussed in section 10 of [1].
60c59,61
<     /* The precision in bits */
---
>     // Sources with the license are here: https://github.com/c4f7fcce9cb06515/Schubfach/blob/3c92d3c9b1fead540616c918cdfef432bca53dfa/todec/src/math/FloatToDecimal.java
> 
>     // The precision in bits.
63c64
<     /* Exponent width in bits */
---
>     // Exponent width in bits.
66,67c67,68
<     /* Minimum value of the exponent: -(2^(W-1)) - P + 3 */
<     static final int Q_MIN = (-1 << (W - 1)) - P + 3;
---
>     // Minimum value of the exponent: -(2^(W-1)) - P + 3.
>     static final int Q_MIN = (-1 << W - 1) - P + 3;
69,70c70,71
<     /* Maximum value of the exponent: 2^(W-1) - P */
<     static final int Q_MAX = (1 << (W - 1)) - P;
---
>     // Maximum value of the exponent: 2^(W-1) - P.
>     static final int Q_MAX = (1 << W - 1) - P;
72c73
<     /* 10^(E_MIN - 1) <= MIN_VALUE < 10^E_MIN */
---
>     // 10^(E_MIN - 1) <= MIN_VALUE < 10^E_MIN
75c76
<     /* 10^(E_MAX - 1) <= MAX_VALUE < 10^E_MAX */
---
>     // 10^(E_MAX - 1) <= MAX_VALUE < 10^E_MAX
78c79
<     /* Threshold to detect tiny values, as in section 8.2.1 of [1] */
---
>     // Threshold to detect tiny values, as in section 8.1.1 of [1]
81c82
<     /* The minimum and maximum k, as in section 8 of [1] */
---
>     // The minimum and maximum k, as in section 8 of [1]
85c86
<     /* H is as in section 8.1 of [1] */
---
>     // H is as in section 8 of [1].
88,89c89,90
<     /* Minimum value of the significand of a normal value: 2^(P-1) */
<     private static final long C_MIN = 1L << (P - 1);
---
>     // Minimum value of the significand of a normal value: 2^(P-1).
>     private static final long C_MIN = 1L << P - 1;
91c92
<     /* Mask to extract the biased exponent */
---
>     // Mask to extract the biased exponent.
94,95c95,96
<     /* Mask to extract the fraction bits */
<     private static final long T_MASK = (1L << (P - 1)) - 1;
---
>     // Mask to extract the fraction bits.
>     private static final long T_MASK = (1L << P - 1) - 1;
97c98
<     /* Used in rop() */
---
>     // Used in rop().
100c101
<     /* Used for left-to-tight digit extraction */
---
>     // Used for left-to-tight digit extraction.
103,108c104,113
<     private static final int NON_SPECIAL    = 0;
<     private static final int PLUS_ZERO      = 1;
<     private static final int MINUS_ZERO     = 2;
<     private static final int PLUS_INF       = 3;
<     private static final int MINUS_INF      = 4;
<     private static final int NAN            = 5;
---
>     private static final int NON_SPECIAL = 0;
>     private static final int PLUS_ZERO = 1;
>     private static final int MINUS_ZERO = 2;
>     private static final int PLUS_INF = 3;
>     private static final int MINUS_INF = 4;
>     private static final int NAN = 5;
> 
>     // For thread-safety, each thread gets its own instance of this class.
>     private static final ThreadLocal<DoubleToDecimal> threadLocal =
>             ThreadLocal.withInitial(DoubleToDecimal::new);
111,115c116,120
<      * Room for the longer of the forms
<      *     -ddddd.dddddddddddd         H + 2 characters
<      *     -0.00ddddddddddddddddd      H + 5 characters
<      *     -d.ddddddddddddddddE-eee    H + 7 characters
<      * where there are H digits d
---
>     Room for the longer of the forms
>         -ddddd.dddddddddddd         H + 2 characters
>         -0.00ddddddddddddddddd      H + 5 characters
>         -d.ddddddddddddddddE-eee    H + 7 characters
>     where there are H digits d
117c122
<     public static final int MAX_CHARS = H + 7;
---
>     public final int MAX_CHARS = H + 7;
118a124
>     // Numerical results are created here...
121c127,130
<     /* Index into bytes of rightmost valid character */
---
>     // ... and copied here in appendTo()
>     private final char[] chars = new char[MAX_CHARS];
> 
>     // Index into bytes of rightmost valid character.
128,129c137,189
<      * Returns a string representation of the {@code double}
<      * argument. All characters mentioned below are ASCII characters.
---
>      * Returns a string rendering of the {@code double} argument.
>      *
>      * <p>The characters of the result are all drawn from the ASCII set.
>      * <ul>
>      * <li> Any NaN, whether quiet or signaling, is rendered as
>      * {@code "NaN"}, regardless of the sign bit.
>      * <li> The infinities +&infin; and -&infin; are rendered as
>      * {@code "Infinity"} and {@code "-Infinity"}, respectively.
>      * <li> The positive and negative zeroes are rendered as
>      * {@code "0.0"} and {@code "-0.0"}, respectively.
>      * <li> A finite negative {@code v} is rendered as the sign
>      * '{@code -}' followed by the rendering of the magnitude -{@code v}.
>      * <li> A finite positive {@code v} is rendered in two stages:
>      * <ul>
>      * <li> <em>Selection of a decimal</em>: A well-defined
>      * decimal <i>d</i><sub><code>v</code></sub> is selected
>      * to represent {@code v}.
>      * <li> <em>Formatting as a string</em>: The decimal
>      * <i>d</i><sub><code>v</code></sub> is formatted as a string,
>      * either in plain or in computerized scientific notation,
>      * depending on its value.
>      * </ul>
>      * </ul>
>      *
>      * <p>A <em>decimal</em> is a number of the form
>      * <i>d</i>&times;10<sup><i>i</i></sup>
>      * for some (unique) integers <i>d</i> &gt; 0 and <i>i</i> such that
>      * <i>d</i> is not a multiple of 10.
>      * These integers are the <em>significand</em> and
>      * the <em>exponent</em>, respectively, of the decimal.
>      * The <em>length</em> of the decimal is the (unique)
>      * integer <i>n</i> meeting
>      * 10<sup><i>n</i>-1</sup> &le; <i>d</i> &lt; 10<sup><i>n</i></sup>.
>      *
>      * <p>The decimal <i>d</i><sub><code>v</code></sub>
>      * for a finite positive {@code v} is defined as follows:
>      * <ul>
>      * <li>Let <i>R</i> be the set of all decimals that round to {@code v}
>      * according to the usual round-to-closest rule of
>      * IEEE 754 floating-point arithmetic.
>      * <li>Let <i>m</i> be the minimal length over all decimals in <i>R</i>.
>      * <li>When <i>m</i> &ge; 2, let <i>T</i> be the set of all decimals
>      * in <i>R</i> with length <i>m</i>.
>      * Otherwise, let <i>T</i> be the set of all decimals
>      * in <i>R</i> with length 1 or 2.
>      * <li>Define <i>d</i><sub><code>v</code></sub> as
>      * the decimal in <i>T</i> that is closest to {@code v}.
>      * Or if there are two such decimals in <i>T</i>,
>      * select the one with the even significand (there is exactly one).
>      * </ul>
>      *
>      * <p>The (uniquely) selected decimal <i>d</i><sub><code>v</code></sub>
>      * is then formatted.
131,133c191,247
<      * @param   v   the {@code double} to be converted.
<      * @return a string representation of the argument.
<      * @see Double#toString(double)
---
>      * <p>Let <i>d</i>, <i>i</i> and <i>n</i> be the significand, exponent and
>      * length of <i>d</i><sub><code>v</code></sub>, respectively.
>      * Further, let <i>e</i> = <i>n</i> + <i>i</i> - 1 and let
>      * <i>d</i><sub>1</sub>&hellip;<i>d</i><sub><i>n</i></sub>
>      * be the usual decimal expansion of the significand.
>      * Note that <i>d</i><sub>1</sub> &ne; 0 &ne; <i>d</i><sub><i>n</i></sub>.
>      * <ul>
>      * <li>Case -3 &le; <i>e</i> &lt; 0:
>      * <i>d</i><sub><code>v</code></sub> is formatted as
>      * <code>0.0</code>&hellip;<code>0</code><!--
>      * --><i>d</i><sub>1</sub>&hellip;<i>d</i><sub><i>n</i></sub>,
>      * where there are exactly -(<i>n</i> + <i>i</i>) zeroes between
>      * the decimal point and <i>d</i><sub>1</sub>.
>      * For example, 123 &times; 10<sup>-4</sup> is formatted as
>      * {@code 0.0123}.
>      * <li>Case 0 &le; <i>e</i> &lt; 7:
>      * <ul>
>      * <li>Subcase <i>i</i> &ge; 0:
>      * <i>d</i><sub><code>v</code></sub> is formatted as
>      * <i>d</i><sub>1</sub>&hellip;<i>d</i><sub><i>n</i></sub><!--
>      * --><code>0</code>&hellip;<code>0.0</code>,
>      * where there are exactly <i>i</i> zeroes
>      * between <i>d</i><sub><i>n</i></sub> and the decimal point.
>      * For example, 123 &times; 10<sup>2</sup> is formatted as
>      * {@code 12300.0}.
>      * <li>Subcase <i>i</i> &lt; 0:
>      * <i>d</i><sub><code>v</code></sub> is formatted as
>      * <i>d</i><sub>1</sub>&hellip;<!--
>      * --><i>d</i><sub><i>n</i>+<i>i</i></sub>.<!--
>      * --><i>d</i><sub><i>n</i>+<i>i</i>+1</sub>&hellip;<!--
>      * --><i>d</i><sub><i>n</i></sub>.
>      * There are exactly -<i>i</i> digits to the right of
>      * the decimal point.
>      * For example, 123 &times; 10<sup>-1</sup> is formatted as
>      * {@code 12.3}.
>      * </ul>
>      * <li>Case <i>e</i> &lt; -3 or <i>e</i> &ge; 7:
>      * computerized scientific notation is used to format
>      * <i>d</i><sub><code>v</code></sub>.
>      * Here <i>e</i> is formatted as by {@link Integer#toString(int)}.
>      * <ul>
>      * <li>Subcase <i>n</i> = 1:
>      * <i>d</i><sub><code>v</code></sub> is formatted as
>      * <i>d</i><sub>1</sub><code>.0E</code><i>e</i>.
>      * For example, 1 &times; 10<sup>23</sup> is formatted as
>      * {@code 1.0E23}.
>      * <li>Subcase <i>n</i> &gt; 1:
>      * <i>d</i><sub><code>v</code></sub> is formatted as
>      * <i>d</i><sub>1</sub><code>.</code><i>d</i><sub>2</sub><!--
>      * -->&hellip;<i>d</i><sub><i>n</i></sub><code>E</code><i>e</i>.
>      * For example, 123 &times; 10<sup>-21</sup> is formatted as
>      * {@code 1.23E-19}.
>      * </ul>
>      * </ul>
>      *
>      * @param v the {@code double} to be rendered.
>      * @return a string rendering of the argument.
136c250
<         return new DoubleToDecimal().toDecimalString(v);
---
>         return threadLocalInstance().toDecimalString(v);
152c266,270
<         return new DoubleToDecimal().appendDecimalTo(v, app);
---
>         return threadLocalInstance().appendDecimalTo(v, app);
>     }
> 
>     private static DoubleToDecimal threadLocalInstance() {
>         return threadLocal.get();
170,171c288
<                 char[] chars = new char[index + 1];
<                 for (int i = 0; i < chars.length; ++i) {
---
>                 for (int i = 0; i <= index; ++i) {
175c292
<                     return ((StringBuilder) app).append(chars);
---
>                     return ((StringBuilder) app).append(chars, 0, index + 1);
178c295
<                     return ((StringBuffer) app).append(chars);
---
>                     return ((StringBuffer) app).append(chars, 0, index + 1);
180,181c297,298
<                 for (char c : chars) {
<                     app.append(c);
---
>                 for (int i = 0; i <= index; ++i) {
>                     app.append(chars[i]);
193,198c310,315
<      * Returns
<      *     PLUS_ZERO       iff v is 0.0
<      *     MINUS_ZERO      iff v is -0.0
<      *     PLUS_INF        iff v is POSITIVE_INFINITY
<      *     MINUS_INF       iff v is NEGATIVE_INFINITY
<      *     NAN             iff v is NaN
---
>     Returns
>         PLUS_ZERO       iff v is 0.0
>         MINUS_ZERO      iff v is -0.0
>         PLUS_INF        iff v is POSITIVE_INFINITY
>         MINUS_INF       iff v is NEGATIVE_INFINITY
>         NAN             iff v is NaN
202,208c319,325
<          * For full details see references [2] and [1].
<          *
<          * For finite v != 0, determine integers c and q such that
<          *     |v| = c 2^q    and
<          *     Q_MIN <= q <= Q_MAX    and
<          *         either    2^(P-1) <= c < 2^P                 (normal)
<          *         or        0 < c < 2^(P-1)  and  q = Q_MIN    (subnormal)
---
>         For full details see references [2] and [1].
> 
>         For finite v != 0, determine integers c and q such that
>             |v| = c 2^q    and
>             Q_MIN <= q <= Q_MAX    and
>                 either    2^(P-1) <= c < 2^P                 (normal)
>                 or        0 < c < 2^(P-1)  and  q = Q_MIN    (subnormal)
219c336
<                 /* normal value. Here mq = -q */
---
>                 // normal value. Here mq = -q
222c339
<                 /* The fast path discussed in section 8.3 of [1] */
---
>                 // The fast path discussed in section 8.2 of [1].
232c349
<                 /* subnormal value */
---
>                 // subnormal value
247,261c364,378
<          * The skeleton corresponds to figure 7 of [1].
<          * The efficient computations are those summarized in figure 9.
<          *
<          * Here's a correspondence between Java names and names in [1],
<          * expressed as approximate LaTeX source code and informally.
<          * Other names are identical.
<          * cb:     \bar{c}     "c-bar"
<          * cbr:    \bar{c}_r   "c-bar-r"
<          * cbl:    \bar{c}_l   "c-bar-l"
<          *
<          * vb:     \bar{v}     "v-bar"
<          * vbr:    \bar{v}_r   "v-bar-r"
<          * vbl:    \bar{v}_l   "v-bar-l"
<          *
<          * rop:    r_o'        "r-o-prime"
---
>         The skeleton corresponds to figure 4 of [1].
>         The efficient computations are those summarized in figure 7.
> 
>         Here's a correspondence between Java names and names in [1],
>         expressed as approximate LaTeX source code and informally.
>         Other names are identical.
>         cb:     \bar{c}     "c-bar"
>         cbr:    \bar{c}_r   "c-bar-r"
>         cbl:    \bar{c}_l   "c-bar-l"
> 
>         vb:     \bar{v}     "v-bar"
>         vbr:    \bar{v}_r   "v-bar-r"
>         vbl:    \bar{v}_l   "v-bar-l"
> 
>         rop:    r_o'        "r-o-prime"
269,271c386,388
<          * flog10pow2(e) = floor(log_10(2^e))
<          * flog10threeQuartersPow2(e) = floor(log_10(3/4 2^e))
<          * flog2pow10(e) = floor(log_2(10^e))
---
>         flog10pow2(e) = floor(log_10(2^e))
>         flog10threeQuartersPow2(e) = floor(log_10(3/4 2^e))
>         flog2pow10(e) = floor(log_2(10^e))
274c391
<             /* regular spacing */
---
>             // regular spacing
278c395
<             /* irregular spacing */
---
>             // irregular spacing
284c401
<         /* g1 and g0 are as in section 9.8.3 of [1], so g = g1 2^63 + g0 */
---
>         // g1 and g0 are as in section 9.9.3 of [1], so g = g1 2^63 + g0
295,303c412,420
<              * For n = 17, m = 1 the table in section 10 of [1] shows
<              *     s' = floor(s / 10) = floor(s 115_292_150_460_684_698 / 2^60)
<              *        = floor(s 115_292_150_460_684_698 2^4 / 2^64)
<              *
<              * sp10 = 10 s'
<              * tp10 = 10 t'
<              * upin    iff    u' = sp10 10^k in Rv
<              * wpin    iff    w' = tp10 10^k in Rv
<              * See section 9.3 of [1].
---
>             For n = 17, m = 1 the table in section 10 of [1] shows
>                 s' = floor(s / 10) = floor(s 115_292_150_460_684_698 / 2^60)
>                    = floor(s 115_292_150_460_684_698 2^4 / 2^64)
> 
>             sp10 = 10 s'
>             tp10 = 10 t'
>             upin    iff    u' = sp10 10^k in Rv
>             wpin    iff    w' = tp10 10^k in Rv
>             See section 9.4 of [1].
315,318c432,435
<          * 10 <= s < 100    or    s >= 100  and  u', w' not in Rv
<          * uin    iff    u = s 10^k in Rv
<          * win    iff    w = t 10^k in Rv
<          * See section 9.3 of [1].
---
>         10 <= s < 100    or    s >= 100  and  u', w' not in Rv
>         uin    iff    u = s 10^k in Rv
>         win    iff    w = t 10^k in Rv
>         See section 9.4 of [1].
324c441
<             /* Exactly one of u or w lies in Rv */
---
>             // Exactly one of u or w lies in Rv.
328,329c445,446
<          * Both u and w lie in Rv: determine the one closest to v.
<          * See section 9.3 of [1].
---
>         Both u and w lie in Rv: determine the one closest to v.
>         See section 9.4 of [1].
336,337c453,454
<      * Computes rop(cp g 2^(-127)), where g = g1 2^63 + g0
<      * See section 9.9 and figure 8 of [1].
---
>     Computes rop(cp g 2^(-127)), where g = g1 2^63 + g0
>     See section 9.10 and figure 5 of [1].
349c466
<      * Formats the decimal f 10^e.
---
>     Formats the decimal f 10^e.
353,356c470,473
<          * For details not discussed here see section 10 of [1].
<          *
<          * Determine len such that
<          *     10^(len-1) <= f < 10^len
---
>         For details not discussed here see section 10 of [1].
> 
>         Determine len such that
>             10^(len-1) <= f < 10^len
364,367c481,484
<          * Let fp and ep be the original f and e, respectively.
<          * Transform f and e to ensure
<          *     10^(H-1) <= f < 10^H
<          *     fp 10^ep = f 10^(e-H) = 0.f 10^e
---
>         Let fp and ep be the original f and e, respectively.
>         Transform f and e to ensure
>             10^(H-1) <= f < 10^H
>             fp 10^ep = f 10^(e-H) = 0.f 10^e
373,384c490,501
<          * The toChars?() methods perform left-to-right digits extraction
<          * using ints, provided that the arguments are limited to 8 digits.
<          * Therefore, split the H = 17 digits of f into:
<          *     h = the most significant digit of f
<          *     m = the next 8 most significant digits of f
<          *     l = the last 8, least significant digits of f
<          *
<          * For n = 17, m = 8 the table in section 10 of [1] shows
<          *     floor(f / 10^8) = floor(193_428_131_138_340_668 f / 2^84) =
<          *     floor(floor(193_428_131_138_340_668 f / 2^64) / 2^20)
<          * and for n = 9, m = 8
<          *     floor(hm / 10^8) = floor(1_441_151_881 hm / 2^57)
---
>         The toChars?() methods perform left-to-right digits extraction
>         using ints, provided that the arguments are limited to 8 digits.
>         Therefore, split the H = 17 digits of f into:
>             h = the most significant digit of f
>             m = the next 8 most significant digits of f
>             l = the last 8, least significant digits of f
> 
>         For n = 17, m = 8 the table in section 10 of [1] shows
>             floor(f / 10^8) = floor(193_428_131_138_340_668 f / 2^84) =
>             floor(floor(193_428_131_138_340_668 f / 2^64) / 2^20)
>         and for n = 9, m = 8
>             floor(hm / 10^8) = floor(1_441_151_881 hm / 2^57)
402,404c519,521
<          * 0 < e <= 7: plain format without leading zeroes.
<          * Left-to-right digits extraction:
<          * algorithm 1 in [3], with b = 10, k = 8, n = 28.
---
>         0 < e <= 7: plain format without leading zeroes.
>         Left-to-right digits extraction:
>         algorithm 1 in [3], with b = 10, k = 8, n = 28.
426c543
<         /* -3 < e <= 0: plain format with leading zeroes */
---
>         // -3 < e <= 0: plain format with leading zeroes.
439c556
<         /* -3 >= e | e > 7: computerized scientific notation */
---
>         // -3 >= e | e > 7: computerized scientific notation
457,458c574,575
<          * Left-to-right digits extraction:
<          * algorithm 1 in [3], with b = 10, k = 8, n = 28.
---
>         Left-to-right digits extraction:
>         algorithm 1 in [3], with b = 10, k = 8, n = 28.
472c589
<         /* ... but do not remove the one directly to the right of '.' */
---
>         // ... but do not remove the one directly to the right of '.'
480,485c597,602
<          * Algorithm 1 in [3] needs computation of
<          *     floor((a + 1) 2^n / b^k) - 1
<          * with a < 10^8, b = 10, k = 8, n = 28.
<          * Noting that
<          *     (a + 1) 2^n <= 10^8 2^28 < 10^17
<          * For n = 17, m = 8 the table in section 10 of [1] leads to:
---
>         Algorithm 1 in [3] needs computation of
>             floor((a + 1) 2^n / b^k) - 1
>         with a < 10^8, b = 10, k = 8, n = 28.
>         Noting that
>             (a + 1) 2^n <= 10^8 2^28 < 10^17
>         For n = 17, m = 8 the table in section 10 of [1] leads to:
505,506c622,623
<              * For n = 3, m = 2 the table in section 10 of [1] shows
<              *     floor(e / 100) = floor(1_311 e / 2^17)
---
>             For n = 3, m = 2 the table in section 10 of [1] shows
>                 floor(e / 100) = floor(1_311 e / 2^17)
513,514c630,631
<          * For n = 2, m = 1 the table in section 10 of [1] shows
<          *     floor(e / 10) = floor(103 e / 2^10)
---
>         For n = 2, m = 1 the table in section 10 of [1] shows
>             floor(e / 10) = floor(103 e / 2^10)
529c646
<     /* Using the deprecated constructor enhances performance */
---
>     // Using the deprecated constructor enhances performance.
