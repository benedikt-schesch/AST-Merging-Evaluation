Only in .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git: AUTO_MERGE
diff -u -r -x '*/\.git*' .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/config .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/config
--- .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/config	2023-08-14 14:25:30.859796579 +0200
+++ .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/config	2023-08-14 14:19:39.050650847 +0200
@@ -9,6 +9,3 @@
 [branch "master"]
 	remote = origin
 	merge = refs/heads/master
-[merge "spork"]
-    name = spork
-    driver = java -jar /home/scheschb/Git/AST-Merging-Evaluation/jars/spork.jar --git-mode %A %O %B -o %A
Binary files .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/index and .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/index differ
diff -u -r -x '*/\.git*' .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/logs/HEAD .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/logs/HEAD
--- .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/logs/HEAD	2023-08-14 14:25:32.311784687 +0200
+++ .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/logs/HEAD	2023-08-14 14:25:33.727773089 +0200
@@ -1,7 +1,6 @@
 0000000000000000000000000000000000000000 b04396ba1a8bf094494f9ba514ecbe806fdb9776 Benedikt Schesch <b.schesch@gmail.com> 1692015579 +0200	clone: from https://github.com/pedrovgs/Algorithms.git
-b04396ba1a8bf094494f9ba514ecbe806fdb9776 2c4e69eb243a81ba05d24456b3cad7e8a696f630 Benedikt Schesch <b.schesch@gmail.com> 1692015930 +0200	checkout: moving from master to 2c4e69eb243a81ba05d24456b3cad7e8a696f630
-2c4e69eb243a81ba05d24456b3cad7e8a696f630 2c4e69eb243a81ba05d24456b3cad7e8a696f630 Benedikt Schesch <b.schesch@gmail.com> 1692015930 +0200	checkout: moving from 2c4e69eb243a81ba05d24456b3cad7e8a696f630 to ___MERGE_TESTER_LEFT
-2c4e69eb243a81ba05d24456b3cad7e8a696f630 8a1a1a7fb53732edaf17ef9876545c4bca568e05 Benedikt Schesch <b.schesch@gmail.com> 1692015930 +0200	checkout: moving from ___MERGE_TESTER_LEFT to 8a1a1a7fb53732edaf17ef9876545c4bca568e05
-8a1a1a7fb53732edaf17ef9876545c4bca568e05 8a1a1a7fb53732edaf17ef9876545c4bca568e05 Benedikt Schesch <b.schesch@gmail.com> 1692015930 +0200	checkout: moving from 8a1a1a7fb53732edaf17ef9876545c4bca568e05 to ___MERGE_TESTER_RIGHT
-8a1a1a7fb53732edaf17ef9876545c4bca568e05 2c4e69eb243a81ba05d24456b3cad7e8a696f630 Benedikt Schesch <b.schesch@gmail.com> 1692015930 +0200	checkout: moving from ___MERGE_TESTER_RIGHT to ___MERGE_TESTER_LEFT
-2c4e69eb243a81ba05d24456b3cad7e8a696f630 fa327e921262b036444cd1bede378121ab7fb8cb Benedikt Schesch <b.schesch@gmail.com> 1692015930 +0200	merge ___MERGE_TESTER_RIGHT: Merge made by the 'ort' strategy.
+b04396ba1a8bf094494f9ba514ecbe806fdb9776 2c4e69eb243a81ba05d24456b3cad7e8a696f630 Benedikt Schesch <b.schesch@gmail.com> 1692015932 +0200	checkout: moving from master to 2c4e69eb243a81ba05d24456b3cad7e8a696f630
+2c4e69eb243a81ba05d24456b3cad7e8a696f630 2c4e69eb243a81ba05d24456b3cad7e8a696f630 Benedikt Schesch <b.schesch@gmail.com> 1692015932 +0200	checkout: moving from 2c4e69eb243a81ba05d24456b3cad7e8a696f630 to ___MERGE_TESTER_LEFT
+2c4e69eb243a81ba05d24456b3cad7e8a696f630 8a1a1a7fb53732edaf17ef9876545c4bca568e05 Benedikt Schesch <b.schesch@gmail.com> 1692015932 +0200	checkout: moving from ___MERGE_TESTER_LEFT to 8a1a1a7fb53732edaf17ef9876545c4bca568e05
+8a1a1a7fb53732edaf17ef9876545c4bca568e05 8a1a1a7fb53732edaf17ef9876545c4bca568e05 Benedikt Schesch <b.schesch@gmail.com> 1692015933 +0200	checkout: moving from 8a1a1a7fb53732edaf17ef9876545c4bca568e05 to ___MERGE_TESTER_RIGHT
+8a1a1a7fb53732edaf17ef9876545c4bca568e05 2c4e69eb243a81ba05d24456b3cad7e8a696f630 Benedikt Schesch <b.schesch@gmail.com> 1692015933 +0200	checkout: moving from ___MERGE_TESTER_RIGHT to ___MERGE_TESTER_LEFT
diff -u -r -x '*/\.git*' .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/logs/refs/heads/___MERGE_TESTER_LEFT .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/logs/refs/heads/___MERGE_TESTER_LEFT
--- .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/logs/refs/heads/___MERGE_TESTER_LEFT	2023-08-14 14:25:32.311784687 +0200
+++ .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/logs/refs/heads/___MERGE_TESTER_LEFT	2023-08-14 14:25:32.931779610 +0200
@@ -1,2 +1 @@
-0000000000000000000000000000000000000000 2c4e69eb243a81ba05d24456b3cad7e8a696f630 Benedikt Schesch <b.schesch@gmail.com> 1692015930 +0200	branch: Created from HEAD
-2c4e69eb243a81ba05d24456b3cad7e8a696f630 fa327e921262b036444cd1bede378121ab7fb8cb Benedikt Schesch <b.schesch@gmail.com> 1692015930 +0200	merge ___MERGE_TESTER_RIGHT: Merge made by the 'ort' strategy.
+0000000000000000000000000000000000000000 2c4e69eb243a81ba05d24456b3cad7e8a696f630 Benedikt Schesch <b.schesch@gmail.com> 1692015932 +0200	branch: Created from HEAD
diff -u -r -x '*/\.git*' .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/logs/refs/heads/___MERGE_TESTER_RIGHT .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/logs/refs/heads/___MERGE_TESTER_RIGHT
--- .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/logs/refs/heads/___MERGE_TESTER_RIGHT	2023-08-14 14:25:30.843796710 +0200
+++ .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/logs/refs/heads/___MERGE_TESTER_RIGHT	2023-08-14 14:25:33.327776366 +0200
@@ -1 +1 @@
-0000000000000000000000000000000000000000 8a1a1a7fb53732edaf17ef9876545c4bca568e05 Benedikt Schesch <b.schesch@gmail.com> 1692015930 +0200	branch: Created from HEAD
+0000000000000000000000000000000000000000 8a1a1a7fb53732edaf17ef9876545c4bca568e05 Benedikt Schesch <b.schesch@gmail.com> 1692015933 +0200	branch: Created from HEAD
Only in .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git: MERGE_HEAD
Only in .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git: MERGE_MODE
Only in .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git: MERGE_MSG
Only in .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/objects: 03
Only in .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/objects: 1a
Only in .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/objects: 21
Only in .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/objects: 29
Only in .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/objects: 6f
Only in .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/objects: 7f
Only in .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/objects: 83
Only in .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/objects: 87
Only in .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/objects: 8b
Only in .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/objects: 8c
Only in .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/objects: a6
Only in .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/objects: b8
Only in .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/objects: c7
Only in .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/objects: e7
Only in .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/objects: fa
Only in .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/objects: fb
Only in .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/objects: ff
diff -u -r -x '*/\.git*' .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/refs/heads/___MERGE_TESTER_LEFT .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/refs/heads/___MERGE_TESTER_LEFT
--- .workdir/59222497567e4472a2991e99db269dfa/Algorithms/.git/refs/heads/___MERGE_TESTER_LEFT	2023-08-14 14:25:32.311784687 +0200
+++ .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/.git/refs/heads/___MERGE_TESTER_LEFT	2023-08-14 14:25:32.931779610 +0200
@@ -1 +1 @@
-fa327e921262b036444cd1bede378121ab7fb8cb
+2c4e69eb243a81ba05d24456b3cad7e8a696f630
Only in .workdir/59222497567e4472a2991e99db269dfa/Algorithms: .gitattributes
diff -u -r -x '*/\.git*' .workdir/59222497567e4472a2991e99db269dfa/Algorithms/src/main/java/com/github/pedrovgs/problem8/SplitArray.java .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/src/main/java/com/github/pedrovgs/problem8/SplitArray.java
--- .workdir/59222497567e4472a2991e99db269dfa/Algorithms/src/main/java/com/github/pedrovgs/problem8/SplitArray.java	2023-08-14 14:25:32.311784687 +0200
+++ .workdir/2d26e6493b384f7aadefee56df68507f/Algorithms/src/main/java/com/github/pedrovgs/problem8/SplitArray.java	2023-08-14 14:25:33.747772926 +0200
@@ -15,8 +15,6 @@
  */
 package com.github.pedrovgs.problem8;
 
-
-
 /**
  * Given an array full of integers positive or negative write a method to move every negative number
  * to the left and every positive number to the right. Take into account that the order of this
@@ -27,32 +25,22 @@
  * @author Pedro Vicente Gómez Sánchez.
  */
 public class SplitArray {
-  /**
-   * First solution implemented for this problem. It's is based on a sorting algorithm called
-   * "Bubble Sorting Algorithm".
-   *
-   * The complexity order in this O(N^2) where N is number of elements in the array. Is even worst
-   * than the bubble sorting algorithm because to check if we have to swap any element is really
-   * expensive. In space terms, the complexity order of this algorithm is O(1) because we are not
-   * using any additional data structure.
-   */
-  public void splitSorting(int[] array) {
-    if (array == null) {
-      throw new IllegalArgumentException("Array passed as parameter can't be null.");
-    }
 
-    boolean flag = true;
-    while (flag) {
-      flag = false;
-      for (int j = 0; j < array.length - 1; j++) {
-        if (array[j] > array[j + 1]) {
-          swap(array, j, j + 1);
-          flag = true;
+    /**
+     * First solution implemented for this problem. It's is based on a sorting algorithm called
+     * "Bubble Sorting Algorithm".
+     *
+     * The complexity order in this O(N^2) where N is number of elements in the array. Is even worst
+     * than the bubble sorting algorithm because to check if we have to swap any element is really
+     * expensive. In space terms, the complexity order of this algorithm is O(1) because we are not
+     * using any additional data structure.
+     */
+    public void splitSorting(int[] array) {
+        if (array == null) {
+            throw new IllegalArgumentException("Array passed as parameter can't be null.");
         }
-      }
-    }
-  }
 
+<<<<<<< HEAD
   /**
    * This solution for the problem is much faster than the previous one. Instead of use a sorting
    * algorithm we are going to go over the array from left to right using two pointers and swapping
@@ -64,6 +52,7 @@
     if (array == null) {
       throw new IllegalArgumentException("Array passed as parameter can't be null.");
     }
+
     int left = 0;
     int right = array.length - 1;
     while (left < right) {
@@ -73,12 +62,14 @@
         swap(array, left, right);
         left++;
         right--;
-      } else if (!shouldChangeLeft) {
-        left++;
-      } else if (!shouldChangeRight) {
-        right--;
+      } else {
+        if (!shouldChangeLeft) {
+          left++;
+        } else if (!shouldChangeRight) {
+          right--;
+        }
       }
-    } 
+    }
   }
 
   /**
@@ -88,21 +79,22 @@
     if (array == null) {
       throw new IllegalArgumentException("Array passed as parameter can't be null.");
     }
+
     int left = 0;
     int right = array.length - 1;
     while (left < right) {
-      while ((array[left] < 0) && (left < right)) {
+      while (array[left] < 0 && left < right) {
         left++;
-      } 
-      while ((array[right] >= 0) && (left < right)) {
+      }
+      while (array[right] >= 0 && left < right) {
         right--;
-      } 
+      }
       if (left < right) {
         swap(array, left, right);
         left++;
         right--;
       }
-    } 
+    }
   }
 
   /**
@@ -115,33 +107,113 @@
   public void splitSwappingRecursive(int[] array) {
     if (array == null) {
       throw new IllegalArgumentException("Array passed as parameter can't be null.");
+=======
+        boolean flag = true;
+        while (flag) {
+            flag = false;
+            for (int j = 0; j < array.length - 1; j++) {
+                if (array[j] > array[j + 1]) {
+                    swap(array, j, j + 1);
+                    flag = true;
+                }
+            }
+        }
+>>>>>>> ___MERGE_TESTER_RIGHT
+    }
+
+    /**
+     * This solution for the problem is much faster than the previous one. Instead of use a sorting
+     * algorithm we are going to go over the array from left to right using two pointers and swapping
+     * elements if needed. The complexity order of this algorithm in time terms is O(N) where N is
+     * the number of elements in the array. In space terms is O(1) because we are not using any
+     * additional data structure.
+     */
+    public void splitSwappingIterative(int[] array) {
+        if (array == null) {
+            throw new IllegalArgumentException("Array passed as parameter can't be null.");
+        }
+
+        int left = 0;
+        int right = array.length - 1;
+        while (left < right) {
+            boolean shouldChangeLeft = array[left] >= 0;
+            boolean shouldChangeRight = array[right] < 0;
+            if (shouldChangeLeft && shouldChangeRight) {
+                swap(array, left, right);
+                left++;
+                right--;
+            } else {
+                if (!shouldChangeLeft) {
+                    left++;
+                } else if (!shouldChangeRight) {
+                    right--;
+                }
+            }
+        }
     }
-    if (array.length == 0) {
-      return;
+
+    /**
+     * Using partition Method of quicksort to split array
+     */
+    public void splitSwappingPartition(int[] array) {
+        if (array == null) {
+            throw new IllegalArgumentException("Array passed as parameter can't be null.");
+        }
+
+        int left = 0;
+        int right = array.length - 1;
+        while (left < right) {
+            while (array[left] < 0 && left < right)
+                left++;
+            while (array[right] >= 0 && left < right)
+                right--;
+            if (left < right) {
+                swap(array, left, right);
+                left++;
+                right--;
+            }
+        }
     }
-    splitSwappingRecursiveInner(array, 0, array.length - 1);
-  }
 
-  private void splitSwappingRecursiveInner(int[] array, int left, int right) {
-    if (left < right) {
-      boolean shouldChangeLeft = array[left] >= 0;
-      boolean shouldChangeRight = array[right] < 0;
-      if (shouldChangeLeft && shouldChangeRight) {
-        swap(array, left, right);
-        splitSwappingRecursiveInner(array, left + 1, right - 1);
-      } else {
-        if (!shouldChangeLeft) {
-          splitSwappingRecursiveInner(array, left + 1, right);
-        } else if (!shouldChangeRight) {
-          splitSwappingRecursiveInner(array, left, right - 1);
+    /**
+     * Tail recursive solution for this problem. This implementation has the same complexity order
+     * O(N) and the only change is how we are going to iterate over the array, with the previous
+     * implementation we are using a classic iterative approach and with this solution we are using
+     * recursion to iterate. In space terms is O(1) because we are not using any
+     * additional data structure.
+     */
+    public void splitSwappingRecursive(int[] array) {
+        if (array == null) {
+            throw new IllegalArgumentException("Array passed as parameter can't be null.");
         }
-      }
+
+        if (array.length == 0) {
+            return;
+        }
+
+        splitSwappingRecursiveInner(array, 0, array.length - 1);
     }
-  }
 
-  private void swap(int[] array, int left, int right) {
-    int aux = array[right];
-    array[right] = array[left];
-    array[left] = aux;
-  }
-}
\ No newline at end of file
+    private void splitSwappingRecursiveInner(int[] array, int left, int right) {
+        if (left < right) {
+            boolean shouldChangeLeft = array[left] >= 0;
+            boolean shouldChangeRight = array[right] < 0;
+            if (shouldChangeLeft && shouldChangeRight) {
+                swap(array, left, right);
+                splitSwappingRecursiveInner(array, left + 1, right - 1);
+            } else {
+                if (!shouldChangeLeft) {
+                    splitSwappingRecursiveInner(array, left + 1, right);
+                } else if (!shouldChangeRight) {
+                    splitSwappingRecursiveInner(array, left, right - 1);
+                }
+            }
+        }
+    }
+
+    private void swap(int[] array, int left, int right) {
+        int aux = array[right];
+        array[right] = array[left];
+        array[left] = aux;
+    }
+}
